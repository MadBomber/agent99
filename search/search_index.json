{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Agent99 Framework Documentation","text":"<p>Welcome to the comprehensive documentation for Agent99 - a Ruby framework for building distributed AI agents with peer-to-peer messaging capabilities.</p>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>New to Agent99? Start here to get up and running quickly:</p> <ul> <li>Overview - What is Agent99 and what can it do?</li> <li>Installation - Get Agent99 installed and configured</li> <li>Quick Start - Build your first agent in minutes  </li> <li>Basic Example - Detailed walkthrough of a complete system</li> </ul>"},{"location":"#core-concepts","title":"\ud83e\udde0 Core Concepts","text":"<p>Understand the fundamental concepts behind Agent99:</p> <ul> <li>What is an Agent? - Basic agent concepts and philosophy</li> <li>Agent Types - Server, Client, and Hybrid agents explained</li> <li>Agent Lifecycle - How agents start, run, and stop</li> <li>Architecture Overview - System design and component interaction</li> </ul>"},{"location":"#framework-components","title":"\ud83d\udd27 Framework Components","text":"<p>Deep dive into the Agent99 system components:</p> <ul> <li>Agent Registry - Central agent discovery service</li> <li>Agent Discovery - How agents find each other</li> <li>Messaging System - AMQP, NATS, and TCP messaging</li> <li>Message Processing - Request/response handling</li> </ul>"},{"location":"#agent-development","title":"\ud83d\udcbb Agent Development","text":"<p>Build your own agents with these guides:</p> <ul> <li>Custom Agent Implementation - Create custom agents</li> <li>Schema Definition - Request/response validation  </li> <li>Request &amp; Response Handling - Message processing patterns</li> <li>Error Handling &amp; Logging - Robust error strategies</li> </ul>"},{"location":"#advanced-topics","title":"\ud83c\udfaf Advanced Topics","text":"<p>Advanced features and integration patterns:</p> <ul> <li>Control Actions - Agent control and management</li> <li>Advanced Features - Dynamic loading and multi-agent processing</li> <li>A2A Protocol - Agent-to-Agent communication protocol  </li> <li>Model Context Protocol - AI model integration</li> <li>Extending the Framework - Custom modules and extensions</li> </ul>"},{"location":"#api-reference","title":"\ud83d\udcda API Reference","text":"<p>Detailed API documentation:</p> <ul> <li>Agent99::Base - Core agent class reference</li> <li>Registry Client - Registry service API  </li> <li>Message Clients - Messaging client APIs</li> <li>Schemas - Schema validation system</li> </ul>"},{"location":"#operations","title":"\u2699\ufe0f Operations","text":"<p>Deploy and maintain Agent99 in production:</p> <ul> <li>Configuration - Environment and runtime configuration</li> <li>Security - Security best practices and implementation</li> <li>Performance Considerations - Optimization and scaling</li> <li>Troubleshooting - Common issues and solutions</li> <li>Breaking Changes - Version upgrade guide</li> </ul>"},{"location":"#examples","title":"\ud83d\udca1 Examples","text":"<p>Working examples and tutorials:</p> <ul> <li>Basic Examples - Simple agent patterns and use cases</li> <li>Advanced Examples - Complex multi-agent scenarios</li> </ul>"},{"location":"#recent-updates","title":"\ud83d\udd04 Recent Updates","text":""},{"location":"#2024-12-12-version-004-release","title":"2024-12-12 - Version 0.0.4 Release","text":"<ul> <li>Breaking changes in agent registration and discovery</li> <li>Improved message processing performance</li> <li>Enhanced error handling and logging</li> </ul>"},{"location":"#2025-04-09-a2a-protocol-integration","title":"2025-04-09 - A2A Protocol Integration","text":"<p>Google announced its Agent-to-Agent public protocol called A2A. Agent99 is designed to integrate with this protocol. For additional information see A2A Protocol Documentation.</p>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Agent99 is an open-source project and welcomes contributions:</p> <ul> <li>GitHub Repository: https://github.com/MadBomber/agent99</li> <li>RubyGems Package: https://rubygems.org/gems/agent99</li> <li>Issue Tracker: Report bugs and request features on GitHub</li> </ul> <p>Ready to build distributed agent systems? Start with the Getting Started guide!</p>"},{"location":"AI/htm/","title":"Hierarchical Temporal Memory in AI Systems","text":""},{"location":"AI/htm/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Understanding Hierarchical Temporal Memory</li> <li>Layers of Memory</li> <li>Topic Columns</li> <li>Memory Cell Promotion and Forgetting</li> <li>Implications for AI Systems</li> <li>Conclusion</li> <li>Some Code Ideas</li> </ul>"},{"location":"AI/htm/#introduction","title":"Introduction","text":"<p>Hierarchical Temporal Memory (HTM) is a computational model that mimics some aspects of the neocortex, developed by the Numenta research company. It focuses on how the brain processes information over time and is designed to learn patterns and sequences in data. HTM operates on principles of hierarchy, meaning it organizes information in layers, and temporal memory, which enables it to remember sequences and make predictions based on temporal patterns. This model is particularly effective for tasks involving time series data and has applications in anomaly detection, robotics, and various cognitive computing tasks.</p>"},{"location":"AI/htm/#understanding-hierarchical-temporal-memory","title":"Understanding Hierarchical Temporal Memory","text":"<p>Hierarchical Temporal Memory is inspired by the theory of how the brain works, particularly focusing on how it learns patterns and sequences. The fundamental ideas were put forward by Jeff Hawkins, co-founder of Numenta, who theorized that real intelligence is derived from understanding and manipulating temporal sequences.</p> <p>HTM leverages a structure that is hierarchical and spatially organized. Each level of the hierarchy processes information at varying degrees of abstraction. The bottom layers deal with raw sensory input, while the upper layers interpret this data into meaningful contexts.</p> <p>This model is particularly valuable in applications involving complex time series, where the demand for understanding sequences over time is crucial. The capability of HTM to generalize from sparse data makes it unique compared to traditional machine learning techniques.</p>"},{"location":"AI/htm/#layers-of-memory","title":"Layers of Memory","text":"<p>HTM's architecture consists of several layers, each designed for specific functions. The bottom layer, known as the input layer, is responsible for receiving raw data inputs. Subsequent layers process this information, identifying patterns and sequences that inform decisions.</p> <ol> <li>Input Layer: Receives sensory data and converts it into a usable format for the next layer.</li> <li>Temporal Pooling Layer: Captures the temporal dependencies in the data.</li> <li>Spatial Pooling Layer: Encodes spatial relationships and builds a representation of the input data.</li> </ol> <p>This multi-layered approach enables HTM to build increasingly sophisticated representations of the data at each layer, akin to how the neocortex might operate.</p>"},{"location":"AI/htm/#topic-columns","title":"Topic Columns","text":"<p>Each \"column\" in HTM can be viewed as a mini-neural network that processes input from the layer below it. These columns work in parallel to learn spatial and temporal patterns. Thus, they respond to specific features of the incoming data, allowing HTM to develop a hierarchy of data features. Columns also facilitate learning through inhibition, promoting the most active neurons while suppressing others.</p>"},{"location":"AI/htm/#memory-cell-promotion-and-forgetting","title":"Memory Cell Promotion and Forgetting","text":"<p>The mechanisms by which HTM promotes or forgets memory cells mirror more biological processes. </p>"},{"location":"AI/htm/#promotion","title":"Promotion","text":"<p>Cells that consistently provide accurate predictions based on the learned sequence are promoted. For instance, if certain neurons within a column recognize patterns that lead to accurate outcomes, they're trained to engage more actively depending on their performance over time.</p>"},{"location":"AI/htm/#forgetting","title":"Forgetting","text":"<p>Forgetting is equally important; neurons that fail to respond to valid sequences are gradually demoted. This ensures that the model does not become overly reliant on outdated information, allowing new patterns and sequences to emerge and be incorporated.</p>"},{"location":"AI/htm/#implications-for-ai-systems","title":"Implications for AI Systems","text":"<p>By modeling the functioning of the neocortex, HTM introduces a new paradigm in machine learning, emphasizing time and sequences over static data processing. This has significant implications in various fields:</p> <ul> <li>Anomaly Detection: In finance, HTM can be used to identify unusual patterns in transactions that may indicate fraud.</li> <li>Robotics: Robots leveraging HTM can learn from their experiences in real-time, adapting to environmental changes dynamically.</li> <li>Natural Language Processing: Understanding the temporal relationships between phrases can enhance language models, leading to more contextually accurate interpretations.</li> </ul>"},{"location":"AI/htm/#conclusion","title":"Conclusion","text":"<p>Hierarchical Temporal Memory presents a powerful framework for understanding and replicating the cognitive processes of the human brain. With its ability to learn from temporal patterns, it opens new frontiers in artificial intelligence and machine learning.</p>"},{"location":"AI/htm/#some-code-ideas","title":"Some Code Ideas","text":"<pre><code>require 'active_record'\n\nclass CreateHtmTable &lt; ActiveRecord::Migration[7.0]\n  def change\n    create_table :htm do |t|\n      t.uuid     :event,         null: false\n      t.text     :proposition,   null: false\n      t.string   :state,         null: false\n      t.datetime :last_accessed, null: false\n      t.integer  :hit_count,     null: false, default: 0\n      t.float    :vector,        null: false, array: true, limit: 2048\n\n      t.timestamps\n    end\n\n    add_index :htm, :event, unique: true\n    add_index :htm, :state\n\n    execute &lt;&lt;-SQL\n      ALTER TABLE htm\n      ADD CONSTRAINT check_state\n      CHECK (state IN ('STM', 'MTM', 'LTM', 'PM'))\n    SQL\n\n    execute &lt;&lt;-SQL\n      ALTER TABLE htm\n      ADD CONSTRAINT check_vector_length\n      CHECK (array_length(vector, 1) = 2048)\n    SQL\n  end\nend\n</code></pre> <p>This is a notional model for the table. I'm having second thoughts about keeping track of the hit count. I think maybe access time is all that is needed and that is provided by the AR timestamps.</p> <pre><code>require 'active_record'\nrequire 'neighbors'\n\nclass Htm &lt; ActiveRecord::Base\n  STATES = %w[STM MTM LTM PM].freeze\n\n  validates :event,       presence: true\n  validates :proposition, presence: true\n  validates :state,       presence: true, inclusion: { in: STATES }\n  validates :vector,      presence: true, length: { is: 2048 }\n\n  def self.search_and_update(event_uuid:, query_vector:, top_k: 10)\n    records = where(event: event_uuid)\n    vectors = records.pluck(:vector)\n\n    neighbor_search = Neighbors::NearestNeighbors.new(vectors)\n    nearest_indices = neighbor_search.search(query_vector, k: top_k)\n\n    nearest_records = records.where(id: records.ids.values_at(*nearest_indices))\n\n    nearest_records.each do |record|\n      record.hit_count     += 1\n      record.last_accessed  = Time.current\n      record.save!\n    end\n\n    nearest_records\n  end\n\n  def update_state\n    event_config = StateConfig.find_by(event: event)\n    current_time = Time.current\n    time_since_creation = current_time - created_at\n    time_since_last_access = current_time - last_accessed\n\n    if should_promote?(event_config, time_since_creation)\n      promote_state\n    elsif should_demote?(event_config, time_since_last_access)\n      demote_state\n    end\n  end\n\n  private\n\n  def should_promote?(config, time_delta)\n    current_state_index = STATES.index(state)\n    return false if current_state_index == STATES.length - 1\n\n    next_state = STATES[current_state_index + 1]\n    time_delta &gt; config.promotion_time(next_state) &amp;&amp;\n      hit_count &gt; config.promotion_hits(next_state)\n  end\n\n  def should_demote?(config, time_delta)\n    current_state_index = STATES.index(state)\n    return false if current_state_index == 0\n\n    time_delta &lt; config.demotion_time(state) &amp;&amp;\n      hit_count &lt; config.demotion_hits(state)\n  end\n\n  def promote_state\n    current_index = STATES.index(state)\n    self.state    = STATES[current_index + 1] if current_index &lt; STATES.length - 1\n    save!\n  end\n\n  def demote_state\n    current_index = STATES.index(state)\n    self.state    = STATES[current_index - 1] if current_index &gt; 0\n    save!\n  end\nend\n\nclass StateConfig &lt; ActiveRecord::Base\n  def promotion_time(state)\n    case state\n    when 'MTM' then mtm_promotion_time\n    when 'LTM' then ltm_promotion_time\n    when 'PM'  then pm_promotion_time\n    else 0\n    end\n  end\n\n  def promotion_hits(state)\n    case state\n    when 'MTM' then mtm_promotion_hits\n    when 'LTM' then ltm_promotion_hits\n    when 'PM'  then pm_promotion_hits\n    else 0\n    end\n  end\n\n  def demotion_time(state)\n    case state\n    when 'MTM' then mtm_demotion_time\n    when 'LTM' then ltm_demotion_time\n    when 'PM'  then pm_demotion_time\n    else Float::INFINITY\n    end\n  end\n\n  def demotion_hits(state)\n    case state\n    when 'MTM' then mtm_demotion_hits\n    when 'LTM' then ltm_demotion_hits\n    when 'PM'  then pm_demotion_hits\n    else Float::INFINITY\n    end\n  end\nend\n</code></pre>"},{"location":"AI/notes_on_htm_implementation/","title":"Notes on HTM Implementation","text":"<p>ruby-12-15 18:49:23] INFO: # backend=\"mods\" chat?=true completion=nil config_file=nil debug?=false directives=#\\ dump_file=nil edit?=false erb?=false extra=\"\" fuzzy?=false help?=false image_quality=\"\" image_size=\"\" log_file=#\\ markdown?=true model=\"gpt-4o-mini\" next=\"\" out_file=#\\&gt; pipeline=#\\ prompts_dir=#\\ render?=false role=\"\" roles_dir=#\\ shell?=false speak?=false speech_model=\"tts-1\" terse?=false transcription_model=\"wisper-1\" verbose?=true version?=false voice=\"alloy\"&gt; <p>[2024-12-15 18:51:14] INFO: PROMPT ID ruby_expert PATH:     /Users/dewayne/.prompts/ruby_expert.txt KEYWORDS: [DO_WHAT]</p> <p>As an experienced Ruby software engineer when giving tasks involving the Ruby programming language, use modern Ruby 3.3 syntax, especially for hashes and method signatures with named parameters when generating Ruby source code.  Whe you do generate Ruby source code I want the following formatting to be used.  Consecutive assignment statements will have theirh \"=\" character in the same column.  This also applies for the the insert operator \"&lt;&lt;\" as well.  When formatting a Hash statement all values will start in the same column.</p> <p>I would like to talk through an idean that I have for implemenmtion something like heirarchical temporal memory at the database level.  do you know what HTM is</p> <p>RESULT:   Yes, I'm familiar with Hierarchical Temporal Memory (HTM). HTM is a machine learning   technology that aims to capture the structural and algorithmic properties of the neocortex in   the human brain. It's designed to model temporal sequences of patterns and make predictions   based on learned sequences.</p> <p>The key features of HTM include:</p> <ol> <li>Sparse Distributed Representations</li> <li>Temporal learning</li> <li>Hierarchical structure</li> <li>Online learning</li> <li>Anomaly detection</li> </ol> <p>Implementing HTM at the database level is an interesting concept. It could potentially allow   for more intelligent data storage, retrieval, and analysis directly within the database   system. This could lead to more efficient processing of time-series data, better pattern   recognition, and improved predictive capabilities built into the database itself.</p> <p>Would you like to discuss specific aspects of how you're thinking of implementing HTM at the   database level? For example:</p> <ol> <li>How would you represent the hierarchical structure in the database schema?</li> <li>Are you considering implementing the learning algorithms within the database, or just the   data structure?</li> <li>What kind of queries or operations do you envision for interacting with the HTM-like   structure?</li> <li>Are there specific use cases or types of data you're targeting with this implementation?</li> </ol> <p>Let me know which aspects you'd like to explore further, and I'd be happy to discuss them in   more detail.</p> <p>[2024-12-15 18:56:41] INFO: Follow Up: I was thinking about using knowledge graphs to represent a topic of discourse based upon the idea that I can construct a KG that spans the range of detail about the topic from most general to most detailed.  what do you thing about that?</p> <p>[2024-12-15 18:56:41] INFO: Response:   That's an intriguing approach! Using knowledge graphs to represent a topic of discourse with   varying levels of detail is a powerful idea. It aligns well with the hierarchical nature of   HTM and could provide a flexible, scalable way to represent and navigate complex information.   Let's explore this concept further:</p> <p>Advantages of this approach:</p> <ol> <li> <p>Hierarchical Representation: Knowledge graphs naturally support hierarchical structures,   which aligns well with the HTM concept.</p> </li> <li> <p>Flexibility: You can easily add new nodes and relationships at any level of detail.</p> </li> <li> <p>Contextual Understanding: The relationships between concepts at different levels can   provide rich context.</p> </li> <li> <p>Scalability: Knowledge graphs can handle large amounts of interconnected data efficiently.</p> </li> <li> <p>Query Flexibility: Graph databases allow for complex queries that can traverse the   hierarchy efficiently.</p> </li> </ol> <p>Implementation considerations:</p> <ol> <li> <p>Graph Database: You might want to use a graph database like Neo4j or Amazon Neptune to   store and query your knowledge graph efficiently.</p> </li> <li> <p>Node Types: You could have different node types representing different levels of   abstraction or detail.</p> </li> <li> <p>Edge Types: Define relationships that connect nodes both horizontally (related concepts)   and vertically (more general/more specific).</p> </li> <li> <p>Metadata: Include metadata on nodes to indicate their level of detail or abstraction.</p> </li> </ol> <p>Here's a simple Ruby example of how you might start to model this:</p> <pre><code>class KnowledgeNode\nattr_reader :id, :content, :detail_level\n\ndef initialize(id:, content:, detail_level:)\n@id = id\n@content = content\n@detail_level = detail_level\n@connections = {\nmore_general: [],\nmore_specific: [],\nrelated: []\n}\nend\n\ndef add_connection(node:, relationship:)\n@connections[relationship] &lt;&lt; node\nend\nend\n\nclass KnowledgeGraph\ndef initialize\n@nodes = {}\nend\n\ndef add_node(node:)\n@nodes[node.id] = node\nend\n\ndef connect_nodes(from_id:, to_id:, relationship:)\nfrom_node = @nodes[from_id]\nto_node = @nodes[to_id]\nfrom_node.add_connection(node: to_node, relationship: relationship)\nend\n\ndef get_more_specific(node_id:)\n@nodes[node_id].connections[:more_specific]\nend\n\ndef get_more_general(node_id:)\n@nodes[node_id].connections[:more_general]\nend\nend\n</code></pre> <p>This basic structure allows you to create nodes with different levels of detail and connect   them in a hierarchical manner. You could expand on this to include methods for traversing the   graph, finding paths between concepts, or identifying clusters of related ideas.</p> <p>Some challenges to consider:</p> <ol> <li> <p>Maintaining Consistency: Ensuring that relationships between nodes at different levels   remain consistent as the graph grows.</p> </li> <li> <p>Scalability: As the graph grows, efficient querying and traversal become crucial.</p> </li> <li> <p>Ontology Design: Defining a clear ontology for your knowledge domain to guide the creation   and connection of nodes.</p> </li> <li> <p>Integration with HTM: Considering how to integrate this knowledge graph structure with   HTM's learning and prediction capabilities.</p> </li> </ol> <p>What are your thoughts on this approach? Do you see any specific challenges or opportunities   in implementing this for your use case?</p> <p>[2024-12-15 19:03:35] INFO: Follow Up: Are there any ruby gems that implement knowledge graphs</p> <p>[2024-12-15 19:03:35] INFO: Response:   Yes, there are several Ruby gems that can help you work with knowledge graphs or implement   graph-like structures. While there isn't a gem specifically named \"knowledge graph,\" there are   gems that provide graph database interfaces or graph data structures that could be used to   implement a knowledge graph. Here are a few options:</p> <ol> <li>Neo4j.rb   This is a Ruby wrapper for the Neo4j graph database. It's one of the most popular options for   working with graph structures in Ruby.</li> </ol> <pre><code>gem 'neo4j'\n</code></pre> <p>Example usage:</p> <pre><code>require 'neo4j'\n\nclass Concept\ninclude Neo4j::ActiveNode\nproperty :name, type: String\nproperty :detail_level, type: Integer\n\nhas_many :out, :more_specific, type: :SPECIALIZES, model_class: 'Concept'\nhas_many :in, :more_general, type: :SPECIALIZES, model_class: 'Concept'\nend\n\n# Create nodes\ngeneral = Concept.create(name: \"Science\", detail_level: 1)\nspecific = Concept.create(name: \"Physics\", detail_level: 2)\n\n# Create relationship\ngeneral.more_specific &lt;&lt; specific\n</code></pre> <ol> <li>Ruby-GraphViz   While primarily for visualization, it can be used to create and manipulate graph structures.</li> </ol> <pre><code>gem 'ruby-graphviz'\n</code></pre> <p>Example usage:</p> <pre><code>require 'graphviz'\n\ngraph = GraphViz.new(:G, type: :digraph)\n\nnode1 = graph.add_nodes(\"Science\")\nnode2 = graph.add_nodes(\"Physics\")\n\ngraph.add_edges(node1, node2)\n\n# See knowledge graph visualization at:\n# docs/assets/images/knowledge-graph.svg\n# graph.output(png: \"knowledge_graph.png\")\n</code></pre> <p></p> <ol> <li>RGL (Ruby Graph Library)   A pure Ruby graph library that provides a set of graph data structures and algorithms.</li> </ol> <pre><code>gem 'rgl'\n</code></pre> <p>Example usage:</p> <pre><code>require 'rgl/adjacency'\nrequire 'rgl/dot'\n\ngraph = RGL::DirectedAdjacencyGraph.new\n\ngraph.add_edge('Science', 'Physics')\ngraph.add_edge('Physics', 'Quantum Mechanics')\n\ngraph.write_to_graphic_file('jpg')\n</code></pre> <ol> <li>OrientDB-JRuby   If you're using JRuby, this gem provides access to OrientDB, a multi-model database that   supports graph structures.</li> </ol> <pre><code>gem 'orientdb'\n</code></pre> <p>Example usage:</p> <pre><code>require 'orientdb'\n\ndatabase = OrientDB::Database.new(url: \"remote:localhost/knowledge_graph\")\n\ndatabase.create_vertex_type('Concept')\n\nscience = database.create_vertex('Concept', name: 'Science', detail_level: 1)\nphysics = database.create_vertex('Concept', name: 'Physics', detail_level: 2)\n\ndatabase.create_edge('Specializes', science, physics)\n</code></pre> <p>While these gems don't implement knowledge graphs directly, they provide the building blocks   you'd need to create one. You'd likely need to build additional abstraction layers on top of   these to implement the specific semantics and operations of a knowledge graph for your use   case.</p> <p>Remember to choose the gem that best fits your specific requirements, considering factors like   performance, ease of use, and whether you need a full database solution or just an in-memory   graph structure.</p> <p>[2024-12-15 19:06:02] INFO: Follow Up: is it fair to posit that within the temporal component the most detailed knowledge nodes are forgotten first before the more general nodes.</p> <p>[2024-12-15 19:06:02] INFO: Response:   That's an insightful observation, and it aligns well with both cognitive science research and   practical considerations in knowledge management. Let's explore this idea:</p> <ol> <li> <p>Cognitive Science Perspective:   Research in human memory and learning suggests that general concepts tend to be more resilient   than specific details. This phenomenon is often referred to as the \"gist\" or \"fuzzy-trace\"   theory of memory.</p> </li> <li> <p>Information Theory:   More general nodes typically contain less specific information, making them more compressible   and potentially easier to retain.</p> </li> <li> <p>Practical Knowledge Management:   In many systems, retaining high-level concepts while allowing low-level details to expire can   be an efficient strategy for managing information over time.</p> </li> </ol> <p>Implementing this concept in a Ruby-based knowledge graph system could look something like   this:</p> <pre><code>class KnowledgeNode\nattr_reader :id, :content, :detail_level, :last_accessed\ndef initialize(id:, content:, detail_level:)\n@id = id\n@content = content\n@detail_level = detail_level\n@last_accessed = Time.now\n@connections = {\nmore_general: [],\nmore_specific: [],\nrelated: []\n}\nend\n\ndef access\n@last_accessed = Time.now\nend\n\ndef forgettable?(threshold)\nTime.now - @last_accessed &gt; threshold * (1.0 / @detail_level)\nend\nend\n\nclass TemporalKnowledgeGraph\ndef initialize(forget_threshold: 30 * 24 * 60 * 60) # 30 days in seconds\n@nodes = {}\n@forget_threshold = forget_threshold\nend\n\ndef add_node(node:)\n@nodes[node.id] = node\nend\n\ndef access_node(id:)\nnode = @nodes[id]\nnode.access if node\nnode\nend\n\ndef forget_old_nodes\n@nodes.delete_if do |id, node|\nnode.forgettable?(@forget_threshold)\nend\nend\n\ndef connect_nodes(from_id:, to_id:, relationship:)\nfrom_node = @nodes[from_id]\nto_node = @nodes[to_id]\nfrom_node.connections[relationship] &lt;&lt; to_node if from_node &amp;&amp; to_node\nend\nend\n\n# Usage\ngraph = TemporalKnowledgeGraph.new(forget_threshold: 60 * 60 * 24) # 1 day\n\nnode1 = KnowledgeNode.new(id: 1, content: \"Science\", detail_level: 1)\nnode2 = KnowledgeNode.new(id: 2, content: \"Physics\", detail_level: 2)\nnode3 = KnowledgeNode.new(id: 3, content: \"Quantum Entanglement\", detail_level: 3)\n\ngraph.add_node(node: node1)\ngraph.add_node(node: node2)\ngraph.add_node(node: node3)\n\ngraph.connect_nodes(from_id: 1, to_id: 2, relationship: :more_specific)\ngraph.connect_nodes(from_id: 2, to_id: 3, relationship: :more_specific)\n\n# Simulate passage of time and node access\nsleep(2)\ngraph.access_node(id: 1)\ngraph.access_node(id: 2)\n\nsleep(2)\ngraph.forget_old_nodes\n# At this point, node3 might be forgotten, while node1 and node2 are retained\n</code></pre> <p>This implementation introduces a <code>forgettable?</code> method that takes into account both the time   since last access and the detail level of the node. More detailed nodes (higher   <code>detail_level</code>) will be considered forgettable sooner than more general nodes.</p> <p>Some considerations for this approach:</p> <ol> <li> <p>Balancing Act: You'll need to fine-tune the forgetting threshold and the relationship   between detail level and forgetting speed.</p> </li> <li> <p>Contextual Importance: Some detailed nodes might be more important than others, regardless   of their detail level. You might want to introduce an \"importance\" factor.</p> </li> <li> <p>Cascading Forgetfulness: When a node is forgotten, you might want to update or remove   references to it in connected nodes.</p> </li> <li> <p>Relearning: Consider implementing a mechanism to \"relearn\" forgotten nodes if they become   relevant again.</p> </li> <li> <p>Persistence: If you're storing this graph in a database, you'll need to implement periodic   cleanup operations to remove forgotten nodes.</p> </li> </ol> <p>This approach provides a starting point for implementing a temporal aspect to your knowledge   graph, where more detailed information is more susceptible to being forgotten over time. It's   a complex topic with many nuances, and the exact implementation would depend on your specific   use case and requirements.</p> <p>[2024-12-15 19:11:27] INFO: Follow Up: The reason that I am looking at HTM is for application in retrieval augmented generation RAG in which information consistent with an LLM prompt is retrieved semantically from a presistant data store for inclusion as context to the prompt.  The size of the context windows is often limited with regard to the amount of information by token count that can be added.  I am thinking that HTM with its ability to forget information over time might lead to better results better in this case may mean quick responses</p> <p>[2024-12-15 19:11:27] INFO: Response:   Your insight about using HTM principles for Retrieval Augmented Generation (RAG) is quite   innovative and could indeed lead to more efficient and effective context retrieval. Let's   explore how this could work and how it might be implemented in Ruby.</p> <p>The key advantages of this approach for RAG would be:</p> <ol> <li>Temporal Relevance: More recent or frequently accessed information is prioritized.</li> <li>Hierarchical Context: Ability to provide a mix of general and specific information within   token limits.</li> <li>Adaptive Memory: The system can \"forget\" less relevant details, making room for new   information.</li> </ol> <p>Here's a conceptual implementation in Ruby that combines HTM principles with RAG:</p> <pre><code>require 'set'\n\nclass HTMNode\nattr_reader :id, :content, :detail_level, :last_accessed, :access_count\n\ndef initialize(id:, content:, detail_level:)\n@id = id\n@content = content\n@detail_level = detail_level\n@last_accessed = Time.now\n@access_count = 0\n@connections = Set.new\nend\n\ndef access\n@last_accessed = Time.now\n@access_count += 1\nend\n\ndef add_connection(node)\n@connections.add(node)\nend\n\ndef relevance_score(current_time)\ntime_factor = 1.0 / (current_time - @last_accessed)\ndetail_factor = 1.0 / @detail_level\naccess_factor = Math.log(@access_count + 1)\ntime_factor * detail_factor * access_factor\nend\nend\n\nclass HTMRAG\ndef initialize(forget_threshold: 30 * 24 * 60 * 60) # 30 days in seconds\n@nodes = {}\n@forget_threshold = forget_threshold\nend\n\ndef add_node(node)\n@nodes[node.id] = node\nend\n\ndef connect_nodes(from_id, to_id)\n@nodes[from_id].add_connection(@nodes[to_id])\nend\n\ndef forget_old_nodes\ncurrent_time = Time.now\n@nodes.delete_if do |_, node|\ncurrent_time - node.last_accessed &gt; @forget_threshold\nend\nend\n\ndef retrieve_context(query, max_tokens: 1000)\nrelevant_nodes = find_relevant_nodes(query)\nconstruct_context(relevant_nodes, max_tokens)\nend\n\nprivate\n\ndef find_relevant_nodes(query)\n# This is a placeholder for semantic search\n# In a real implementation, you'd use embeddings or other NLP techniques\n@nodes.values.sort_by { |node| -node.relevance_score(Time.now) }\nend\n\ndef construct_context(nodes, max_tokens)\ncontext = \"\"\ntoken_count = 0\n\nnodes.each do |node|\nbreak if token_count &gt;= max_tokens\n\nnode_content = node.content\nnode_tokens = node_content.split.size # Simple tokenization\n\nif token_count + node_tokens &lt;= max_tokens\ncontext += node_content + \" \"\ntoken_count += node_tokens\nnode.access\nelse\nremaining_tokens = max_tokens - token_count\ntruncated_content = node_content.split[0...remaining_tokens].join(' ')\ncontext += truncated_content + \" \"\nbreak\nend\nend\n\ncontext.strip\nend\nend\n\n# Usage example\nrag = HTMRAG.new\n\nnode1 = HTMNode.new(id: 1, content: \"AI is a broad field of computer science.\", detail_level:\n1)\nnode2 = HTMNode.new(id: 2, content: \"Machine Learning is a subset of AI focused on data-driven\nalgorithms.\", detail_level: 2)\nnode3 = HTMNode.new(id: 3, content: \"Neural networks are a type of machine learning model\ninspired by biological neurons.\", detail_level: 3)\n\nrag.add_node(node1)\nrag.add_node(node2)\nrag.add_node(node3)\n\nrag.connect_nodes(1, 2)\nrag.connect_nodes(2, 3)\n\ncontext = rag.retrieve_context(\"What is AI?\", max_tokens: 50)\nputs context\n</code></pre> <p>This implementation incorporates several key HTM and RAG concepts:</p> <ol> <li>Hierarchical Structure: Nodes have a <code>detail_level</code> attribute.</li> <li>Temporal Aspect: Nodes track <code>last_accessed</code> time and <code>access_count</code>.</li> <li>Relevance Scoring: Combines recency, detail level, and access frequency.</li> <li>Forgetting Mechanism: Old nodes are removed based on a time threshold.</li> <li>Context Construction: Retrieves and combines relevant nodes within token limits.</li> </ol> <p>To make this more effective for RAG:</p> <ol> <li>Semantic Search: Implement a proper semantic search for <code>find_relevant_nodes</code>, possibly   using embeddings.</li> <li>Smarter Tokenization: Use a proper tokenizer that aligns with your LLM.</li> <li>Adaptive Forgetting: Adjust the forgetting threshold based on system performance and data   volume.</li> <li>Contextual Connections: Enhance the connection mechanism to capture semantic relationships   between nodes.</li> </ol> <p>This approach could indeed lead to quicker responses in RAG systems by:</p> <ol> <li>Prioritizing recent and frequently accessed information.</li> <li>Maintaining a balance between general and specific information.</li> <li>Automatically curating the knowledge base over time.</li> <li>Allowing for faster retrieval by maintaining a more focused set of nodes.</li> </ol> <p>Remember, the effectiveness of this system would heavily depend on the quality of your   semantic search and the relevance scoring mechanism. You might need to experiment with   different scoring formulas and parameters to optimize for your specific use case.</p> <p>[2024-12-15 19:17:29] INFO: Follow Up: Instead of the common vectorization of the prompt and a semantic search of the database for the nearest neighbor based upon the vectorization, I was thinking along the lines of breaking the prompt up into a knowledge graph of propositions.  I could then chose from the database those existing graphcs in which their sequences mose closely resembles the sequences in the prompts graph.  does that make sense?</p> <p>[2024-12-15 19:17:29] INFO: Response:   That's a fascinating and innovative approach! It makes a lot of sense and could potentially   offer some significant advantages over traditional vector-based semantic search. Let's break   down this concept and explore how it might be implemented in Ruby.</p> <p>The key ideas in your approach are:</p> <ol> <li>Representing the prompt as a knowledge graph of propositions.</li> <li>Comparing the structure and sequence of this graph to existing graphs in the database.</li> <li>Selecting the most similar graphs for context retrieval.</li> </ol> <p>This approach could indeed provide more nuanced and contextually relevant results, as it takes   into account the relationships and sequence of ideas, not just the overall semantic   similarity.</p> <p>Here's a conceptual implementation in Ruby:</p> <pre><code>class Proposition\nattr_reader :id, :content\nattr_accessor :next, :related\n\ndef initialize(id:, content:)\n@id = id\n@content = content\n@next = nil\n@related = []\nend\nend\n\nclass PropositionGraph\nattr_reader :propositions\n\ndef initialize\n@propositions = {}\nend\n\ndef add_proposition(prop)\n@propositions[prop.id] = prop\nend\n\ndef connect(from_id:, to_id:, relationship: :next)\nfrom_prop = @propositions[from_id]\nto_prop = @propositions[to_id]\nif relationship == :next\nfrom_prop.next = to_prop\nelse\nfrom_prop.related &lt;&lt; to_prop\nend\nend\n\ndef similarity_score(other_graph)\nsequence_similarity = calculate_sequence_similarity(other_graph)\nstructure_similarity = calculate_structure_similarity(other_graph)\n(sequence_similarity + structure_similarity) / 2.0\nend\n\nprivate\n\ndef calculate_sequence_similarity(other_graph)\n# Implement sequence comparison logic here\n# This could involve comparing the 'next' chains of both graphs\n# Return a score between 0 and 1\nend\n\ndef calculate_structure_similarity(other_graph)\n# Implement structure comparison logic here\n# This could involve comparing the 'related' connections of both graphs\n# Return a score between 0 and 1\nend\nend\n\nclass GraphBasedRAG\ndef initialize\n@stored_graphs = []\nend\n\ndef add_graph(graph)\n@stored_graphs &lt;&lt; graph\nend\n\ndef retrieve_context(prompt_graph, top_n: 3)\nscored_graphs = @stored_graphs.map do |graph|\n{\ngraph: graph,\nscore: graph.similarity_score(prompt_graph)\n}\nend\n\ntop_graphs = scored_graphs.sort_by { |g| -g[:score] }.take(top_n)\nconstruct_context(top_graphs)\nend\n\nprivate\n\ndef construct_context(top_graphs)\n# Implement logic to construct context from top graphs\n# This could involve extracting key propositions or summarizing the graphs\nend\nend\n\n# Usage example\nrag = GraphBasedRAG.new\n\n# Create and add some stored graphs\ngraph1 = PropositionGraph.new\nprop1 = Proposition.new(id: 1, content: \"AI is a field of computer science\")\nprop2 = Proposition.new(id: 2, content: \"Machine Learning is a subset of AI\")\ngraph1.add_proposition(prop1)\ngraph1.add_proposition(prop2)\ngraph1.connect(from_id: 1, to_id: 2)\nrag.add_graph(graph1)\n\n# ... Add more graphs ...\n\n# Create a graph from the prompt\nprompt_graph = PropositionGraph.new\nprompt_prop1 = Proposition.new(id: 1, content: \"What is AI\")\nprompt_prop2 = Proposition.new(id: 2, content: \"How does it relate to Machine Learning\")\nprompt_graph.add_proposition(prompt_prop1)\nprompt_graph.add_proposition(prompt_prop2)\nprompt_graph.connect(from_id: 1, to_id: 2)\n\n# Retrieve context\ncontext = rag.retrieve_context(prompt_graph)\nputs context\n</code></pre> <p>This implementation provides a framework for your approach. Some key points:</p> <ol> <li><code>Proposition</code> represents individual ideas or statements.</li> <li><code>PropositionGraph</code> represents a network of related propositions.</li> <li>The <code>similarity_score</code> method in <code>PropositionGraph</code> compares both sequence and structure.</li> <li><code>GraphBasedRAG</code> stores graphs and retrieves the most similar ones for a given prompt graph.</li> </ol> <p>To make this system more effective:</p> <ol> <li>Implement sophisticated graph comparison algorithms in <code>calculate_sequence_similarity</code> and   <code>calculate_structure_similarity</code>.</li> <li>Develop a method to automatically convert natural language prompts into proposition graphs.</li> <li>Optimize the storage and retrieval of graphs for large-scale applications.</li> <li>Implement a method to extract or summarize relevant information from the retrieved graphs.</li> </ol> <p>Advantages of this approach:</p> <ol> <li>Captures relationships between ideas, not just individual concepts.</li> <li>Can potentially handle complex queries more effectively.</li> <li>Might be better at maintaining context and coherence in retrieved information.</li> </ol> <p>Challenges to consider:</p> <ol> <li>Complexity in converting natural language to proposition graphs.</li> <li>Potentially higher computational cost for graph comparisons.</li> <li>Need for sophisticated algorithms to handle graph similarity at scale.</li> </ol> <p>This approach is innovative and has the potential to provide more contextually relevant   results for RAG systems, especially for complex queries where the relationship between   concepts is crucial. It would be particularly effective in domains where the sequence and   structure of information are as important as the content itself.</p> <p>[2024-12-15 19:19:56] INFO: Follow Up: are their graph-based extensions to PostgreSQL that we could use for this project?</p> <p>[2024-12-15 19:19:56] INFO: Response:   Yes, there are indeed graph-based extensions for PostgreSQL that could be very useful for this   project. The most notable one is pgvector, which while not strictly graph-based, provides   vector operations that can be helpful in graph-like queries. However, for true graph   operations, we can look at a few options:</p> <ol> <li>AGE (Apache AGE)   AGE (A Graph Extension) is an extension that adds graph database functionality to PostgreSQL.   It's based on the Cypher query language and supports property graphs.</li> </ol> <p>To use AGE with Ruby, you'd typically use the pg gem and write Cypher queries as strings.   Here's a basic example:</p> <pre><code>require 'pg'\n\nclass GraphDatabase\ndef initialize(dbname:, user:, password:)\n@conn = PG.connect(dbname: dbname, user: user, password: password)\n@conn.exec(\"CREATE EXTENSION IF NOT EXISTS age\")\n@conn.exec(\"LOAD 'age'\")\n@conn.exec(\"SET search_path = ag_catalog, \\\"$user\\\", public\")\nend\n\ndef create_graph(name)\n@conn.exec(\"SELECT create_graph('#{name}')\")\nend\n\ndef add_vertex(graph, properties)\nprops = properties.map { |k, v| \"#{k}: '#{v}'\" }.join(\", \")\n@conn.exec(\"SELECT * FROM cypher('#{graph}', $$ CREATE (:Proposition {#{props}}) $$) as (v\nagtype)\")\nend\n\ndef add_edge(graph, from_id, to_id, relationship)\n@conn.exec(\"SELECT * FROM cypher('#{graph}', $$ MATCH (a), (b) WHERE id(a) = #{from_id} AND\nid(b) = #{to_id} CREATE (a)-[:#{relationship}]-&gt;(b) $$) as (e agtype)\")\nend\n\ndef query(graph, cypher)\nresult = @conn.exec(\"SELECT * FROM cypher('#{graph}', $$ #{cypher} $$) as (result agtype)\")\nresult.map { |row| row['result'] }\nend\nend\n\n# Usage\ndb = GraphDatabase.new(dbname: 'your_db', user: 'your_user', password: 'your_password')\ndb.create_graph('knowledge_graph')\ndb.add_vertex('knowledge_graph', {content: \"AI is a field of computer science\", detail_level:\n1})\ndb.add_vertex('knowledge_graph', {content: \"Machine Learning is a subset of AI\", detail_level:\n2})\ndb.add_edge('knowledge_graph', 0, 1, 'SPECIALIZES')\n\nresult = db.query('knowledge_graph', \"MATCH (p:Proposition) RETURN p\")\nputs result\n</code></pre> <ol> <li> <p>pggraph   pggraph is another extension that adds graph functionality to PostgreSQL. It's less   feature-rich than AGE but might be simpler for some use cases.</p> </li> <li> <p>pgRouting   If your graph operations involve pathfinding or network analysis, pgRouting could be useful.   It's primarily designed for geospatial routing but can be adapted for other types of graphs.</p> </li> </ol> <p>For our specific use case of proposition graphs and RAG, AGE would likely be the most suitable   option. It allows for complex graph structures and queries, which aligns well with the idea of   representing and querying proposition graphs.</p> <p>Here's how you might implement some of the core functionality using AGE:</p> <pre><code>class PropositionGraphDatabase\ndef initialize(dbname:, user:, password:)\n@db = GraphDatabase.new(dbname: dbname, user: user, password: password)\n@db.create_graph('proposition_graph')\nend\n\ndef add_proposition(content:, detail_level:)\n@db.add_vertex('proposition_graph', {content: content, detail_level: detail_level})\nend\n\ndef connect_propositions(from_id:, to_id:, relationship: 'NEXT')\n@db.add_edge('proposition_graph', from_id, to_id, relationship)\nend\n\ndef find_similar_graphs(prompt_graph)\n# This is a simplified example. In practice, you'd need a more sophisticated\n# algorithm to compare graph structures.\ncypher = \"\"\"\nMATCH path = (start:Proposition)-[:NEXT*]-&gt;(end:Proposition)\nWHERE NOT (end)-[:NEXT]-&gt;()\nWITH path, nodes(path) AS props\nRETURN path,\nreduce(similarity = 0, p IN props |\nsimilarity + CASE WHEN p.content CONTAINS '#{prompt_graph.first.content}' THEN 1 ELSE 0 END\n) AS similarity_score\nORDER BY similarity_score DESC\nLIMIT 5\n\"\"\"\n@db.query('proposition_graph', cypher)\nend\nend\n\n# Usage\ngraph_db = PropositionGraphDatabase.new(dbname: 'your_db', user: 'your_user', password:\n'your_password')\ngraph_db.add_proposition(content: \"AI is a field of computer science\", detail_level: 1)\ngraph_db.add_proposition(content: \"Machine Learning is a subset of AI\", detail_level: 2)\ngraph_db.connect_propositions(from_id: 0, to_id: 1)\n\nprompt_graph = [OpenStruct.new(content: \"What is AI\")]\nsimilar_graphs = graph_db.find_similar_graphs(prompt_graph)\nputs similar_graphs\n</code></pre> <p>This approach allows you to leverage PostgreSQL's robustness and scalability while gaining   graph database capabilities. It's particularly well-suited for your proposition graph idea, as   it can represent complex relationships between propositions and allow for sophisticated   querying based on graph structure.</p> <p>Remember that you'll need to install and configure the AGE extension on your PostgreSQL server   before using it. Also, for production use, you'd want to implement more sophisticated graph   comparison algorithms and possibly combine this with vector embeddings for even more accurate   similarity matching.</p> <p>[2024-12-15 19:27:00] INFO: Follow Up: do you know of a goo LLM that would take a block of text for example a paragraph and great a knowledge graph from that text.</p> <p>[2024-12-15 19:27:00] INFO: Response:   Yes, there are several large language models (LLMs) that can be used to generate knowledge   graphs from text. One of the most capable and widely used models for this task is GPT-4 from   OpenAI. While it doesn't directly output a structured knowledge graph, it can be prompted to   generate the components of a knowledge graph, which you can then parse and structure.</p> <p>Here's an example of how you might use GPT-4 (or a similar model) to generate a knowledge   graph from a paragraph of text, and then process the output in Ruby:</p> <pre><code>require 'openai'\nrequire 'json'\n\nclass KnowledgeGraphGenerator\ndef initialize(api_key)\n@client = OpenAI::Client.new(access_token: api_key)\nend\n\ndef generate_graph(text)\nprompt = &lt;&lt;~PROMPT\nGiven the following paragraph, create a knowledge graph.\nOutput the result as a JSON object with the following structure:\n{\n\"nodes\": [\n{\"id\": \"unique_id\", \"label\": \"concept or entity\", \"type\": \"entity_type\"}\n],\n\"edges\": [\n{\"source\": \"source_id\", \"target\": \"target_id\", \"label\": \"relationship\"}\n]\n}\n\nParagraph:\n#{text}\n\nJSON Knowledge Graph:\nPROMPT\n\nresponse = @client.chat(\nparameters: {\nmodel: \"gpt-4\", # or \"gpt-3.5-turbo\" if you don't have GPT-4 access\nmessages: [{ role: \"user\", content: prompt }],\ntemperature: 0.7,\n}\n)\n\nJSON.parse(response.dig(\"choices\", 0, \"message\", \"content\"))\nend\nend\n\nclass KnowledgeGraph\nattr_reader :nodes, :edges\n\ndef initialize(data)\n@nodes = data[\"nodes\"]\n@edges = data[\"edges\"]\nend\n\ndef to_s\n\"Nodes:\\n\" + @nodes.map { |n| \" #{n['id']}: #{n['label']} (#{n['type']})\" }.join(\"\\n\") +\n\"\\nEdges:\\n\" + @edges.map { |e| \" #{e['source']} -&gt; #{e['target']}: #{e['label']}\"\n}.join(\"\\n\")\nend\nend\n\n# Usage\ngenerator = KnowledgeGraphGenerator.new('your-openai-api-key')\n\ntext = \"Artificial Intelligence (AI) is a broad field of computer science focused on creating\nintelligent machines that can perform tasks that typically require human intelligence. Machine\nLearning, a subset of AI, uses statistical techniques to give computer systems the ability to\n'learn' from data, without being explicitly programmed. Deep Learning, a further\nspecialization of Machine Learning, uses neural networks with many layers (hence 'deep') to\nanalyze various factors of data.\"\n\ngraph_data = generator.generate_graph(text)\ngraph = KnowledgeGraph.new(graph_data)\n\nputs graph\n</code></pre> <p>This script does the following:</p> <ol> <li>It uses the OpenAI API to send a prompt to GPT-4, asking it to generate a knowledge graph   from the given text.</li> <li>The prompt specifies the desired output format (a JSON object with nodes and edges).</li> <li>The response from GPT-4 is parsed as JSON.</li> <li>A <code>KnowledgeGraph</code> class is used to represent the graph structure and provide a simple   string representation.</li> </ol> <p>When you run this script, it will output something like:</p> <pre><code>Nodes:\n1: Artificial Intelligence (AI) (field)\n2: Computer Science (field)\n3: Intelligent Machines (concept)\n4: Human Intelligence (concept)\n5: Machine Learning (subfield)\n6: Statistical Techniques (method)\n7: Computer Systems (technology)\n8: Data (concept)\n9: Deep Learning (subfield)\n10: Neural Networks (technology)\nEdges:\n1 -&gt; 2: is part of\n1 -&gt; 3: focuses on creating\n3 -&gt; 4: perform tasks requiring\n5 -&gt; 1: is subset of\n5 -&gt; 6: uses\n6 -&gt; 7: give ability to\n7 -&gt; 8: learn from\n9 -&gt; 5: is specialization of\n9 -&gt; 10: uses\n10 -&gt; 8: analyze\n</code></pre> <p>This approach allows you to generate knowledge graphs from text in a flexible way. However,   keep in mind:</p> <ol> <li>The quality and structure of the generated graph will depend on the capabilities of the LLM   and how well you craft the prompt.</li> <li>You may need to post-process the LLM output to ensure consistency or to adapt it to your   specific needs.</li> <li>This method may not be suitable for processing large volumes of text due to API rate limits   and costs.</li> <li>For production use, you'd want to add error handling and possibly implement retries for API   calls.</li> </ol> <p>For more specialized or consistent results, you might consider fine-tuning a model on   knowledge graph generation tasks, or using a dedicated NLP pipeline with named entity   recognition and relationship extraction components.</p> <p>[2024-12-15 19:31:08] INFO: Follow Up: Lets do an exercise.  I'm going to give you some text and I would like you to give back to me a represention of that text as a knowledge graph.  The text is \"As a resident of Bossier City, LA I am not allowed to drive my 2021 Tahoe LS because of my poor eyesight.\"</p> <p>[2024-12-15 19:31:08] INFO: Response:   Certainly! I'll represent this text as a knowledge graph for you. I'll provide the graph   structure in a JSON format, which can be easily parsed and used in Ruby or other programming   languages.</p> <pre><code>{\n\"nodes\": [\n{\n\"id\": \"1\",\n\"label\": \"Resident\",\n\"type\": \"Person\"\n},\n{\n\"id\": \"2\",\n\"label\": \"Bossier City\",\n\"type\": \"Location\"\n},\n{\n\"id\": \"3\",\n\"label\": \"Louisiana\",\n\"type\": \"Location\"\n},\n{\n\"id\": \"4\",\n\"label\": \"2021 Tahoe LS\",\n\"type\": \"Vehicle\"\n},\n{\n\"id\": \"5\",\n\"label\": \"Poor eyesight\",\n\"type\": \"Condition\"\n},\n{\n\"id\": \"6\",\n\"label\": \"Driving restriction\",\n\"type\": \"Regulation\"\n}\n],\n\"edges\": [\n{\n\"source\": \"1\",\n\"target\": \"2\",\n\"label\": \"resides in\"\n},\n{\n\"source\": \"2\",\n\"target\": \"3\",\n\"label\": \"located in\"\n},\n{\n\"source\": \"1\",\n\"target\": \"4\",\n\"label\": \"owns\"\n},\n{\n\"source\": \"1\",\n\"target\": \"5\",\n\"label\": \"has condition\"\n},\n{\n\"source\": \"1\",\n\"target\": \"6\",\n\"label\": \"subject to\"\n},\n{\n\"source\": \"6\",\n\"target\": \"4\",\n\"label\": \"applies to\"\n},\n{\n\"source\": \"5\",\n\"target\": \"6\",\n\"label\": \"causes\"\n}\n]\n}\n</code></pre> <p>This knowledge graph representation captures the key entities and relationships in the given   text. Here's a breakdown of the graph:</p> <ol> <li>Nodes represent the main entities and concepts:</li> <li>The resident (Person)</li> <li>Bossier City and Louisiana (Locations)</li> <li>2021 Tahoe LS (Vehicle)</li> <li>Poor eyesight (Condition)</li> <li> <p>Driving restriction (Regulation)</p> </li> <li> <p>Edges represent the relationships between these entities:</p> </li> <li>The resident resides in Bossier City, which is located in Louisiana</li> <li>The resident owns the 2021 Tahoe LS</li> <li>The resident has the condition of poor eyesight</li> <li>The resident is subject to a driving restriction</li> <li>The driving restriction applies to the 2021 Tahoe LS</li> <li>The poor eyesight causes the driving restriction</li> </ol> <p>This structure allows for querying and reasoning about the relationships between the entities.   For example, you can easily trace why the resident can't drive their vehicle (poor eyesight   leading to a driving restriction).</p> <p>To use this in Ruby, you could parse the JSON and create a graph structure similar to the one   we discussed earlier:</p> <pre><code>require 'json'\n\nclass KnowledgeGraph\nattr_reader :nodes, :edges\n\ndef initialize(data)\n@nodes = data[\"nodes\"]\n@edges = data[\"edges\"]\nend\n\ndef to_s\n\"Nodes:\\n\" + @nodes.map { |n| \" #{n['id']}: #{n['label']} (#{n['type']})\" }.join(\"\\n\") +\n\"\\nEdges:\\n\" + @edges.map { |e| \" #{e['source']} -&gt; #{e['target']}: #{e['label']}\"\n}.join(\"\\n\")\nend\nend\n\n# Assuming the JSON is stored in a variable called 'json_data'\ngraph_data = JSON.parse(json_data)\ngraph = KnowledgeGraph.new(graph_data)\n\nputs graph\n</code></pre> <p>This would give you a readable representation of the knowledge graph derived from the text.</p> <p>[2024-12-15 19:47:47] INFO: Follow Up: Is there a way that I can display the knowledge graph graphically within a rails application</p> <p>[2024-12-15 19:47:47] INFO: Response:   Absolutely! There are several ways to display a knowledge graph graphically within a Rails   application. One popular and effective approach is to use a JavaScript library for graph   visualization. D3.js is a powerful option, but for simplicity and ease of use, we'll go with   vis.js, which is particularly well-suited for network graphs.</p> <p>Here's a step-by-step guide to implement this in your Rails application:</p> <ol> <li>Add the vis-network library to your Rails application:</li> </ol> <p>Add this line to your <code>app/javascript/application.js</code> file:</p> <pre><code>import \"vis-network/styles/vis-network.css\";\nimport { Network } from \"vis-network/standalone\";\n</code></pre> <p>And add this to your <code>config/importmap.rb</code>:</p> <pre><code>pin \"vis-network\", to:\n\"https://ga.jspm.io/npm:vis-network@9.1.6/standalone/esm/vis-network.js\"\n</code></pre> <ol> <li>Create a controller action to serve the graph data:</li> </ol> <pre><code># app/controllers/knowledge_graphs_controller.rb\nclass KnowledgeGraphsController &lt; ApplicationController\ndef show\n@graph_data = {\nnodes: [\n{ id: 1, label: \"Resident\", group: \"Person\" },\n{ id: 2, label: \"Bossier City\", group: \"Location\" },\n{ id: 3, label: \"Louisiana\", group: \"Location\" },\n{ id: 4, label: \"2021 Tahoe LS\", group: \"Vehicle\" },\n{ id: 5, label: \"Poor eyesight\", group: \"Condition\" },\n{ id: 6, label: \"Driving restriction\", group: \"Regulation\" }\n],\nedges: [\n{ from: 1, to: 2, label: \"resides in\" },\n{ from: 2, to: 3, label: \"located in\" },\n{ from: 1, to: 4, label: \"owns\" },\n{ from: 1, to: 5, label: \"has condition\" },\n{ from: 1, to: 6, label: \"subject to\" },\n{ from: 6, to: 4, label: \"applies to\" },\n{ from: 5, to: 6, label: \"causes\" }\n]\n}\nend\nend\n</code></pre> <ol> <li>Create a view to display the graph:</li> </ol> <pre><code>&lt;!-- app/views/knowledge_graphs/show.html.erb --&gt;\n&lt;div id=\"knowledge-graph\" style=\"width: 100%; height: 600px;\"&gt;&lt;/div&gt;\n\n&lt;%= javascript_tag do %&gt;\ndocument.addEventListener('DOMContentLoaded', function() {\nvar container = document.getElementById('knowledge-graph');\nvar data = {\nnodes: new vis.DataSet(&lt;%= raw @graph_data[:nodes].to_json %&gt;),\nedges: new vis.DataSet(&lt;%= raw @graph_data[:edges].to_json %&gt;)\n};\nvar options = {\nnodes: {\nshape: 'dot',\nsize: 16\n},\nphysics: {\nforceAtlas2Based: {\ngravitationalConstant: -26,\ncentralGravity: 0.005,\nspringLength: 230,\nspringConstant: 0.18\n},\nmaxVelocity: 146,\nsolver: 'forceAtlas2Based',\ntimestep: 0.35,\nstabilization: { iterations: 150 }\n}\n};\nvar network = new vis.Network(container, data, options);\n});\n&lt;% end %&gt;\n</code></pre> <ol> <li>Add a route for the knowledge graph:</li> </ol> <pre><code># config/routes.rb\nRails.application.routes.draw do\nget 'knowledge_graph', to: 'knowledge_graphs#show'\n# ... other routes ...\nend\n</code></pre> <ol> <li>Style the graph (optional):</li> </ol> <p>You can add custom styles to make the graph more visually appealing. Add this to your CSS   (e.g., in <code>app/assets/stylesheets/application.css</code>):</p> <pre><code>#knowledge-graph {\nborder: 1px solid #ddd;\nborder-radius: 4px;\nbox-shadow: 0 0 10px rgba(0,0,0,0.1);\n}\n</code></pre> <p>Now, when you visit <code>/knowledge_graph</code> in your Rails application, you should see a graphical   representation of the knowledge graph.</p> <p>To make this more dynamic:</p> <ol> <li>You could store your graph data in the database and retrieve it in the controller.</li> <li>You could create a form that allows users to input text, which is then processed (possibly   using an LLM as discussed earlier) to generate the graph data.</li> </ol> <p>Here's a quick example of how you might do that:</p> <pre><code># app/controllers/knowledge_graphs_controller.rb\nclass KnowledgeGraphsController &lt; ApplicationController\ndef new\n@knowledge_graph = KnowledgeGraph.new\nend\n\ndef create\n@knowledge_graph = KnowledgeGraph.new(knowledge_graph_params)\nif @knowledge_graph.save\nredirect_to @knowledge_graph\nelse\nrender :new\nend\nend\n\ndef show\n@knowledge_graph = KnowledgeGraph.find(params[:id])\n@graph_data = JSON.parse(@knowledge_graph.graph_data)\nend\n\nprivate\n\ndef knowledge_graph_params\nparams.require(:knowledge_graph).permit(:input_text)\nend\nend\n</code></pre> <p>You would need to create a <code>KnowledgeGraph</code> model that stores the input text and the generated   graph data. The model could include a method to generate the graph data from the input text   (possibly using an LLM API).</p> <p>This setup allows for a more interactive and dynamic knowledge graph visualization in your   Rails application.</p> <p>[2024-12-15 19:49:12] INFO: Follow Up: thank you I believe we have covered the wubject well enough.</p> <p>[2024-12-15 19:49:12] INFO: Response:   You're welcome! I'm glad we were able to cover the subject of knowledge graphs, their   implementation in Ruby and Rails, and their visualization to your satisfaction. This   exploration touched on several important aspects:</p> <ol> <li>The concept of knowledge graphs and their representation</li> <li>Using LLMs to generate knowledge graphs from text</li> <li>Implementing knowledge graph structures in Ruby</li> <li>Visualizing knowledge graphs in a Rails application using JavaScript libraries</li> </ol> <p>These concepts provide a solid foundation for working with knowledge graphs in a Ruby on Rails   environment. If you decide to implement this in a project, you'll have a good starting point   for representing, manipulating, and visualizing complex information structures.</p> <p>If you have any more questions in the future about this topic or any related areas, feel free   to ask. Good luck with your work involving knowledge graphs!</p>"},{"location":"advanced-topics/a2a-protocol/","title":"Agent to Agent (a2a) Protocol","text":"<p>Google just pulically announted their A2A public protocol for inter-agent coordination and discovery.  Its a pretty thick specification much heavier and more complete that what is being proposed here within the Agent99 reference implementation; however, it is at the highest levels consistent with a centralized well-known server, use of HTML for inter-agent communication payloads of JSON packages; and, of course, agents a hetro implementations from anywhere but having the one communication standard in common.</p>"},{"location":"advanced-topics/a2a-protocol/#introductory-blog-post","title":"Introductory Blog Post","text":"<p>https://developers.googleblog.com/en/a2a-a-new-era-of-agent-interoperability/</p>"},{"location":"advanced-topics/a2a-protocol/#complete-specification","title":"Complete Specification","text":"<p>It contains sample applications in python and JavaShit</p> <p>https://github.com/google/A2A</p>"},{"location":"advanced-topics/advanced-features/","title":"Agent99 Framework","text":""},{"location":"advanced-topics/advanced-features/#advanced-features","title":"Advanced Features","text":"<p>Ruby supports dynamic loading and deployment of libraries at runtime.  Agent99 takes advantage of this ability through the <code>AgentWatcher</code> system. This powerful feature allows you to:</p> <ul> <li>Monitor a directory for new agent files</li> <li>Automatically load and instantiate new agents when detected</li> <li>Run multiple agents within the same process</li> <li>Manage agent lifecycle independently</li> </ul>"},{"location":"advanced-topics/advanced-features/#using-agentwatcher","title":"Using AgentWatcher","text":"<p>The <code>AgentWatcher</code> (found in <code>examples/agent_watcher.rb</code>) provides a framework for dynamically loading and running agents:</p> <ol> <li> <p>Start the AgentWatcher: <pre><code>watcher = AgentWatcher.new\nwatcher.run\n</code></pre></p> </li> <li> <p>Deploy new agents by copying their .rb files to the watched directory (default: './agents'): <pre><code>cp my_new_agent.rb agents/\n</code></pre></p> </li> </ol> <p>The AgentWatcher will: - Detect the new file - Load the agent class - Instantiate the agent - Run it in a separate thread</p>"},{"location":"advanced-topics/advanced-features/#example-implementation","title":"Example Implementation","text":"<pre><code>class MyDynamicAgent &lt; Agent99::Base  \n  def info\n    {\n      # ...\n      type:         :server,\n      capabilities: ['my_capability'],\n      # ...\n    }\n  end\n\n  def receive_request\n    # Handle requests\n    send_response(status: 'success')\n  end\nend\n</code></pre>"},{"location":"advanced-topics/advanced-features/#multi-agent-processing","title":"Multi-Agent Processing","text":"<p>Agent99 supports running multiple agents within the same process, with each agent running in its own thread. This approach:</p> <ul> <li>Reduces resource overhead compared to separate processes</li> <li>Maintains isolation between agents</li> <li>Allows efficient inter-agent communication</li> <li>Simplifies agent management</li> </ul>"},{"location":"advanced-topics/advanced-features/#benefits","title":"Benefits","text":"<ol> <li>Resource Efficiency: Share common resources while maintaining agent isolation</li> <li>Simplified Deployment: Manage multiple agents through a single process</li> <li>Enhanced Communication: Direct inter-agent communication within the same process</li> <li>Centralized Management: Monitor and control multiple agents from a single point</li> </ol>"},{"location":"advanced-topics/advanced-features/#implementation-considerations","title":"Implementation Considerations","text":"<p>When running multiple agents in the same process:</p> <ol> <li>Each agent runs in its own thread for isolation</li> <li>Agents can still communicate through the standard messaging system</li> <li>Errors in one agent won't affect others</li> <li>Resource sharing is handled automatically by the framework</li> </ol>"},{"location":"advanced-topics/advanced-features/#example-setup","title":"Example Setup","text":"<p>Using AgentWatcher to manage multiple agents:</p> <pre><code># Start the watcher\nwatcher = AgentWatcher.new\nwatcher.run\n\n# Deploy multiple agents\ncp agent1.rb agents/\ncp agent2.rb agents/\ncp agent3.rb agents/\n</code></pre> <p>Each agent will run independently in its own thread while sharing the same process space.</p>"},{"location":"advanced-topics/advanced-features/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Error Handling</p> <ul> <li>Implement proper error handling in each agent</li> <li>Use the built-in logging system</li> <li>Monitor agent health through status checks</li> </ul> </li> <li> <p>Resource Management</p> <ul> <li>Monitor memory usage when running many agents</li> <li>Implement proper cleanup in the <code>fini</code> method</li> <li>Use appropriate thread pool sizes</li> </ul> </li> <li> <p>Deployment</p> <ul> <li>Use meaningful file names for easy identification</li> <li>Maintain clear separation of concerns between agents</li> <li>Document agent dependencies and requirements</li> </ul> </li> <li> <p>Monitoring</p> <ul> <li>Implement health checks in your agents</li> <li>Use logging for debugging and monitoring</li> <li>Set up appropriate alerting for critical agents</li> </ul> </li> </ol>"},{"location":"advanced-topics/control-actions/","title":"Agent99 Framework","text":""},{"location":"advanced-topics/control-actions/#control-actions","title":"Control Actions","text":"<p>Agent99 provides a robust control system that allows for dynamic management of agents during runtime. Control actions enable administrative operations and state management without requiring agent restarts or redeployment.</p> <p></p>"},{"location":"advanced-topics/control-actions/#built-in-control-actions","title":"Built-in Control Actions","text":"<p>The framework includes several built-in control actions:</p>"},{"location":"advanced-topics/control-actions/#shutdown","title":"shutdown","text":"<ul> <li>Gracefully stops the agent</li> <li>Withdraws registration from the registry</li> <li>Cleans up resources and connections</li> <li>Triggers the <code>fini</code> method</li> <li>Example usage: <pre><code>{\n  header: {\n    type: \"control\",\n    to_uuid: \"target_agent_id\",\n    from_uuid: \"control_agent_id\",\n    event_uuid: \"evt_123\",\n    timestamp: 1638360000000000\n  },\n  action: \"shutdown\"\n}\n</code></pre></li> </ul>"},{"location":"advanced-topics/control-actions/#pause","title":"pause","text":"<p>TODO: haven't decided whether messages are left in the messaging network or whether they should be queued within the agent.  TBD</p> <ul> <li>Temporarily halts message processing</li> <li>Maintains agent registration</li> <li>Continues to accept control messages</li> <li>Queues other messages for later processing</li> <li>Example usage: <pre><code>{\n  header: {\n    type: \"control\",\n    to_uuid: \"target_agent_id\",\n    from_uuid: \"control_agent_id\",\n    event_uuid: \"evt_456\",\n    timestamp: 1638360000000000\n  },\n  action: \"pause\"\n}\n</code></pre></li> </ul>"},{"location":"advanced-topics/control-actions/#resume","title":"resume","text":"<ul> <li>Reactivates a paused agent</li> <li>Processes any queued messages</li> <li>Restores normal operation</li> <li>Example usage: <pre><code>{\n  header: {\n    type: \"control\",\n    to_uuid: \"target_agent_id\",\n    from_uuid: \"control_agent_id\",\n    event_uuid: \"evt_789\",\n    timestamp: 1638360000000000\n  },\n  action: \"resume\"\n}\n</code></pre></li> </ul>"},{"location":"advanced-topics/control-actions/#update_config","title":"update_config","text":"<p>TODO: This is still TBD waiting for the design of the overall configuration class.</p> <ul> <li>Updates agent configuration at runtime</li> <li>Allows dynamic behavior modification</li> <li>Example usage: <pre><code>{\n  header: {\n    type: \"control\",\n    to_uuid: \"target_agent_id\",\n    from_uuid: \"control_agent_id\",\n    event_uuid: \"evt_101\",\n    timestamp: 1638360000000000\n  },\n  action: \"update_config\",\n  config: {\n    \"log_level\": \"DEBUG\",\n    \"timeout\": 30\n  }\n}\n</code></pre></li> </ul>"},{"location":"advanced-topics/control-actions/#status","title":"status","text":"<ul> <li>Requests current agent status</li> <li>Returns operational statistics</li> <li>Example usage: <pre><code>{\n  header: {\n    type: \"control\",\n    to_uuid: \"target_agent_id\",\n    from_uuid: \"control_agent_id\",\n    event_uuid: \"evt_102\",\n    timestamp: 1638360000000000\n  },\n  action: \"status\"\n}\n</code></pre></li> </ul>"},{"location":"advanced-topics/control-actions/#implementing-custom-control-actions","title":"Implementing Custom Control Actions","text":"<p>You can implement custom control actions by:</p> <ol> <li> <p>Adding a handler method to your agent class: <pre><code>def handle_custom_action\n  # Implementation\n  send_control_response(status: \"custom action completed\")\nend\n</code></pre></p> </li> <li> <p>Registering the handler in CONTROL_HANDLERS: <pre><code>CONTROL_HANDLERS.merge!({\n  'custom_action' =&gt; :handle_custom_action\n})\n</code></pre></p> </li> </ol>"},{"location":"advanced-topics/control-actions/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Response Handling</p> <ul> <li>Always send a control response</li> <li>Include relevant status information</li> <li>Handle errors gracefully</li> </ul> </li> <li> <p>State Management</p> <ul> <li>Maintain consistent state transitions</li> <li>Document state dependencies</li> <li>Handle edge cases (e.g., pause while paused)</li> </ul> </li> <li> <p>Security Considerations</p> <ul> <li>Validate control message sources</li> <li>Implement appropriate authorization</li> <li>Log all control actions</li> </ul> </li> <li> <p>Error Recovery</p> <ul> <li>Implement timeout mechanisms</li> <li>Handle partial failures</li> <li>Provide status feedback</li> </ul> </li> </ol>"},{"location":"advanced-topics/control-actions/#control-flow-example","title":"Control Flow Example","text":"<pre><code>class MyAgent &lt; Agent99::Base\n  def handle_custom_restart\n    begin\n      cleanup_resources\n      reinitialize_state\n      send_control_response(status: \"restart completed\")\n    rescue StandardError =&gt; e\n      send_control_response(\n        status: \"restart failed\",\n        error: e.message\n      )\n    end\n  end\nend\n</code></pre>"},{"location":"advanced-topics/control-actions/#monitoring-control-actions","title":"Monitoring Control Actions","text":"<p>All control actions are automatically logged with:    * Timestamp    * Action type    * Source agent    * Result status    * Error information (if any)</p> <p>This enables effective monitoring and troubleshooting of agent behavior and system state.</p>"},{"location":"advanced-topics/extending-the-framework/","title":"Agent99 Framework","text":""},{"location":"advanced-topics/extending-the-framework/#extending-the-framework","title":"Extending the Framework","text":"<p>To extend Agent99:</p> <ol> <li>Implement custom modules and include them in your agents.</li> <li>Define new message types or schemas as needed.</li> <li>Use hooks to add functionality or override existing behavior.</li> </ol> <p>If a plugin system is developed in the future, it would allow for additional features without modifying the core framework.</p>"},{"location":"advanced-topics/model-context-protocol/","title":"Model Context Protocol (MCP)","text":"<p>See: https://modelcontextprotocol.io/introduction</p>"},{"location":"advanced-topics/multi-agent-processing/","title":"Multi-Agent Processing","text":"<p>Multi-agent processing allows you to run multiple agents within the same process or coordinate agents across different processes. This guide covers patterns, strategies, and best practices for multi-agent systems.</p>"},{"location":"advanced-topics/multi-agent-processing/#overview","title":"Overview","text":""},{"location":"advanced-topics/multi-agent-processing/#single-process-multiple-agents","title":"Single Process, Multiple Agents","text":"<p>Running multiple agents in the same Ruby process can be efficient for related services that need to share resources.</p>"},{"location":"advanced-topics/multi-agent-processing/#basic-multi-agent-setup","title":"Basic Multi-Agent Setup","text":"<pre><code>require 'agent99'\n\n# Define your agents\nclass DatabaseAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['database', 'storage']\n    }\n  end\n\n  def process_request(payload)\n    # Database operations\n    operation = payload.dig(:operation)\n    case operation\n    when 'store'\n      result = store_data(payload[:data])\n      send_response(result: result)\n    when 'retrieve'\n      data = retrieve_data(payload[:id])\n      send_response(data: data)\n    else\n      send_error(\"Unknown operation: #{operation}\")\n    end\n  end\nend\n\nclass CacheAgent &lt; Agent99::Base\n  def initialize\n    super\n    @cache = {}\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['cache', 'memory']\n    }\n  end\n\n  def process_request(payload)\n    key = payload.dig(:key)\n    case payload.dig(:operation)\n    when 'get'\n      send_response(value: @cache[key])\n    when 'set'\n      @cache[key] = payload[:value]\n      send_response(status: 'stored')\n    when 'delete'\n      @cache.delete(key)\n      send_response(status: 'deleted')\n    end\n  end\nend\n\nclass LoggingAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['logging', 'audit']\n    }\n  end\n\n  def process_request(payload)\n    # Log the event\n    log_entry = {\n      timestamp: Time.now.iso8601,\n      level: payload[:level] || 'info',\n      message: payload[:message],\n      source: payload[:source]\n    }\n\n    File.open('agent_audit.log', 'a') do |f|\n      f.puts log_entry.to_json\n    end\n\n    send_response(status: 'logged', entry_id: SecureRandom.uuid)\n  end\nend\n\n# Multi-agent process manager\nclass MultiAgentProcess\n  def initialize\n    @agents = []\n    @threads = []\n    @running = false\n  end\n\n  def add_agent(agent_class, options = {})\n    agent = agent_class.new(options)\n    @agents &lt;&lt; agent\n    agent\n  end\n\n  def start_all\n    @running = true\n\n    @agents.each do |agent|\n      thread = Thread.new do\n        begin\n          agent.run\n        rescue =&gt; e\n          puts \"Agent #{agent.class} failed: #{e.message}\"\n        end\n      end\n      @threads &lt;&lt; thread\n    end\n\n    puts \"Started #{@agents.size} agents in #{@threads.size} threads\"\n    self\n  end\n\n  def stop_all\n    @running = false\n\n    @agents.each(&amp;:shutdown)\n    @threads.each(&amp;:join)\n\n    puts \"All agents stopped\"\n  end\n\n  def wait_for_shutdown\n    trap('INT') do\n      puts \"\\nShutting down all agents...\"\n      stop_all\n      exit\n    end\n\n    @threads.each(&amp;:join)\n  end\nend\n\n# Usage\nif __FILE__ == $0\n  process = MultiAgentProcess.new\n\n  # Add agents to the process\n  process.add_agent(DatabaseAgent)\n  process.add_agent(CacheAgent)  \n  process.add_agent(LoggingAgent)\n\n  # Start all agents\n  process.start_all\n\n  # Wait for shutdown signal\n  process.wait_for_shutdown\nend\n</code></pre>"},{"location":"advanced-topics/multi-agent-processing/#agent-coordination-patterns","title":"Agent Coordination Patterns","text":""},{"location":"advanced-topics/multi-agent-processing/#producer-consumer-pattern","title":"Producer-Consumer Pattern","text":"<pre><code>class ProducerAgent &lt; Agent99::Base\n  def initialize\n    super\n    @job_counter = 0\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :hybrid,\n      capabilities: ['producer', 'job_generator']\n    }\n  end\n\n  def start_producing\n    Thread.new do\n      loop do\n        # Find consumer agents\n        consumers = discover_agents(['consumer'])\n\n        if consumers.any?\n          # Create a job\n          job = create_job\n\n          # Send to a random consumer\n          consumer = consumers.sample\n          send_request(consumer[:name], job)\n\n          logger.info \"Sent job #{job[:id]} to #{consumer[:name]}\"\n        else\n          logger.warn \"No consumers available\"\n        end\n\n        sleep(5) # Produce every 5 seconds\n      end\n    end\n  end\n\n  def process_request(payload)\n    # Handle requests for job status, etc.\n    case payload[:operation]\n    when 'status'\n      send_response(jobs_produced: @job_counter, status: 'running')\n    end\n  end\n\n  private\n\n  def create_job\n    @job_counter += 1\n    {\n      id: \"job_#{@job_counter}\",\n      type: 'data_processing',\n      data: Array.new(100) { rand(1000) },\n      created_at: Time.now.iso8601\n    }\n  end\nend\n\nclass ConsumerAgent &lt; Agent99::Base\n  def initialize\n    super\n    @processed_jobs = 0\n  end\n\n  def info\n    {\n      name: \"#{self.class}_#{Socket.gethostname}_#{Process.pid}\",\n      type: :server,\n      capabilities: ['consumer', 'data_processor']\n    }\n  end\n\n  def process_request(payload)\n    job_id = payload.dig(:id)\n    job_type = payload.dig(:type)\n\n    logger.info \"Processing job #{job_id} of type #{job_type}\"\n\n    # Simulate processing time\n    processing_time = rand(1..3)\n    sleep(processing_time)\n\n    # Process the data\n    data = payload.dig(:data) || []\n    result = data.sum / data.size.to_f rescue 0\n\n    @processed_jobs += 1\n\n    send_response(\n      job_id: job_id,\n      result: result,\n      processing_time: processing_time,\n      processed_by: info[:name],\n      total_processed: @processed_jobs\n    )\n\n    logger.info \"Completed job #{job_id}\"\n  end\nend\n</code></pre>"},{"location":"advanced-topics/multi-agent-processing/#load-balancing-pattern","title":"Load Balancing Pattern","text":"<pre><code>class LoadBalancerAgent &lt; Agent99::Base\n  def initialize\n    super\n    @worker_stats = {}\n    @request_count = 0\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :hybrid,\n      capabilities: ['load_balancer', 'proxy']\n    }\n  end\n\n  def process_request(payload)\n    @request_count += 1\n\n    # Find available worker agents\n    workers = discover_agents(['worker'])\n\n    if workers.empty?\n      return send_error(\"No workers available\", \"NO_WORKERS\")\n    end\n\n    # Choose worker based on load balancing strategy\n    chosen_worker = choose_worker(workers)\n\n    # Forward request to chosen worker\n    begin\n      response = send_request(chosen_worker[:name], payload)\n\n      # Update worker stats\n      update_worker_stats(chosen_worker[:name], success: true)\n\n      # Add load balancer info to response\n      response[:routed_by] = info[:name]\n      response[:worker] = chosen_worker[:name]\n\n      send_response(response)\n    rescue =&gt; e\n      update_worker_stats(chosen_worker[:name], success: false)\n      send_error(\"Worker failed: #{e.message}\", \"WORKER_ERROR\")\n    end\n  end\n\n  private\n\n  def choose_worker(workers)\n    # Round-robin load balancing\n    worker_index = @request_count % workers.size\n    workers[worker_index]\n  end\n\n  def update_worker_stats(worker_name, success:)\n    @worker_stats[worker_name] ||= { requests: 0, successes: 0, failures: 0 }\n    @worker_stats[worker_name][:requests] += 1\n\n    if success\n      @worker_stats[worker_name][:successes] += 1\n    else\n      @worker_stats[worker_name][:failures] += 1\n    end\n  end\nend\n\nclass WorkerAgent &lt; Agent99::Base\n  def initialize(worker_id = nil)\n    super()\n    @worker_id = worker_id || \"worker_#{SecureRandom.hex(4)}\"\n  end\n\n  def info\n    {\n      name: \"#{self.class}_#{@worker_id}\",\n      type: :server,\n      capabilities: ['worker', 'processing']\n    }\n  end\n\n  def process_request(payload)\n    # Simulate different processing capabilities\n    task_type = payload.dig(:task_type)\n\n    case task_type\n    when 'cpu_intensive'\n      result = perform_cpu_task(payload[:data])\n    when 'io_intensive'\n      result = perform_io_task(payload[:data])\n    when 'memory_intensive'\n      result = perform_memory_task(payload[:data])\n    else\n      result = perform_generic_task(payload[:data])\n    end\n\n    send_response(\n      result: result,\n      worker_id: @worker_id,\n      task_type: task_type,\n      processed_at: Time.now.iso8601\n    )\n  end\n\n  private\n\n  def perform_cpu_task(data)\n    # Simulate CPU-intensive work\n    (1..1000000).sum\n  end\n\n  def perform_io_task(data)\n    # Simulate I/O work\n    File.write(\"/tmp/worker_#{@worker_id}_output.txt\", data.to_s)\n    \"Data written to file\"\n  end\n\n  def perform_memory_task(data)\n    # Simulate memory-intensive work\n    large_array = Array.new(100000) { rand }\n    large_array.sum\n  end\n\n  def perform_generic_task(data)\n    # Generic task processing\n    \"Processed: #{data}\"\n  end\nend\n</code></pre>"},{"location":"advanced-topics/multi-agent-processing/#multi-process-coordination","title":"Multi-Process Coordination","text":""},{"location":"advanced-topics/multi-agent-processing/#process-manager","title":"Process Manager","text":"<pre><code>class AgentProcessManager\n  def initialize\n    @processes = {}\n  end\n\n  def start_agent_process(agent_class, count: 1, options: {})\n    count.times do |i|\n      process_name = \"#{agent_class.name.downcase}_#{i}\"\n\n      pid = fork do\n        # Set process title for easier identification\n        Process.setproctitle(\"agent99_#{process_name}\")\n\n        # Create and run the agent\n        agent = agent_class.new(options)\n\n        # Handle graceful shutdown\n        trap('TERM') do\n          agent.shutdown\n          exit\n        end\n\n        agent.run\n      end\n\n      @processes[process_name] = {\n        pid: pid,\n        agent_class: agent_class,\n        started_at: Time.now\n      }\n\n      puts \"Started #{agent_class} as process #{pid} (#{process_name})\"\n    end\n  end\n\n  def stop_all_processes\n    @processes.each do |name, process_info|\n      begin\n        Process.kill('TERM', process_info[:pid])\n        Process.wait(process_info[:pid])\n        puts \"Stopped process #{name} (#{process_info[:pid]})\"\n      rescue Errno::ESRCH\n        puts \"Process #{name} (#{process_info[:pid]}) already stopped\"\n      end\n    end\n\n    @processes.clear\n  end\n\n  def monitor_processes\n    Thread.new do\n      loop do\n        @processes.each do |name, process_info|\n          begin\n            # Check if process is still running\n            Process.getpgid(process_info[:pid])\n          rescue Errno::ESRCH\n            puts \"Process #{name} (#{process_info[:pid]}) died, restarting...\"\n            restart_process(name, process_info)\n          end\n        end\n\n        sleep(5) # Check every 5 seconds\n      end\n    end\n  end\n\n  def wait_for_shutdown\n    trap('INT') do\n      puts \"\\nShutting down all agent processes...\"\n      stop_all_processes\n      exit\n    end\n\n    # Wait for all child processes\n    Process.waitall\n  end\n\n  private\n\n  def restart_process(name, process_info)\n    # Remove dead process\n    @processes.delete(name)\n\n    # Start new process\n    start_agent_process(\n      process_info[:agent_class], \n      count: 1,\n      options: process_info[:options] || {}\n    )\n  end\nend\n\n# Usage example\nif __FILE__ == $0\n  manager = AgentProcessManager.new\n\n  # Start multiple instances of different agents\n  manager.start_agent_process(WorkerAgent, count: 3)\n  manager.start_agent_process(LoadBalancerAgent, count: 1)\n  manager.start_agent_process(LoggingAgent, count: 1)\n\n  # Start process monitoring\n  manager.monitor_processes\n\n  # Wait for shutdown\n  manager.wait_for_shutdown\nend\n</code></pre>"},{"location":"advanced-topics/multi-agent-processing/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced-topics/multi-agent-processing/#memory-management","title":"Memory Management","text":"<pre><code>class MemoryEfficientAgent &lt; Agent99::Base\n  def initialize\n    super\n    @request_count = 0\n    @memory_check_interval = 100\n  end\n\n  def process_request(payload)\n    @request_count += 1\n\n    # Periodic memory check\n    if @request_count % @memory_check_interval == 0\n      check_memory_usage\n    end\n\n    # Process request with memory awareness\n    result = process_with_memory_limit(payload)\n    send_response(result)\n  end\n\n  private\n\n  def check_memory_usage\n    # Get current memory usage\n    memory_mb = `ps -o rss= -p #{Process.pid}`.to_i / 1024\n\n    if memory_mb &gt; 500 # 500MB limit\n      logger.warn \"High memory usage: #{memory_mb}MB\"\n\n      # Trigger garbage collection\n      GC.start\n\n      # Check again after GC\n      new_memory_mb = `ps -o rss= -p #{Process.pid}`.to_i / 1024\n      logger.info \"Memory after GC: #{new_memory_mb}MB\"\n    end\n  end\n\n  def process_with_memory_limit(payload)\n    # Implement memory-conscious processing\n    if payload[:data]&amp;.size &gt; 10000\n      # Stream process large data instead of loading all at once\n      process_large_data_streaming(payload[:data])\n    else\n      # Normal processing for small data\n      process_small_data(payload[:data])\n    end\n  end\nend\n</code></pre>"},{"location":"advanced-topics/multi-agent-processing/#thread-pool-management","title":"Thread Pool Management","text":"<pre><code>require 'concurrent-ruby'\n\nclass ThreadPoolAgent &lt; Agent99::Base\n  def initialize(options = {})\n    super(options)\n\n    # Create thread pools for different task types\n    @cpu_pool = Concurrent::ThreadPoolExecutor.new(\n      min_threads: 2,\n      max_threads: 4,\n      max_queue: 100\n    )\n\n    @io_pool = Concurrent::ThreadPoolExecutor.new(\n      min_threads: 5,\n      max_threads: 20,\n      max_queue: 1000\n    )\n  end\n\n  def process_request(payload)\n    task_type = payload.dig(:task_type)\n\n    # Choose appropriate thread pool\n    pool = case task_type\n           when 'cpu_intensive'\n             @cpu_pool\n           when 'io_intensive', 'network'\n             @io_pool\n           else\n             @cpu_pool\n           end\n\n    # Execute in thread pool\n    future = Concurrent::Future.execute(executor: pool) do\n      perform_task(payload)\n    end\n\n    # Wait for completion with timeout\n    begin\n      result = future.value(30) # 30 second timeout\n      send_response(result)\n    rescue Concurrent::TimeoutError\n      send_error(\"Task timed out\", \"TIMEOUT\")\n    rescue =&gt; e\n      send_error(\"Task failed: #{e.message}\", \"EXECUTION_ERROR\")\n    end\n  end\n\n  def shutdown\n    # Shutdown thread pools gracefully\n    [@cpu_pool, @io_pool].each do |pool|\n      pool.shutdown\n      unless pool.wait_for_termination(10)\n        pool.kill\n      end\n    end\n\n    super\n  end\nend\n</code></pre>"},{"location":"advanced-topics/multi-agent-processing/#best-practices","title":"Best Practices","text":""},{"location":"advanced-topics/multi-agent-processing/#1-resource-management","title":"1. Resource Management","text":"<ul> <li>Limit agent count: Don't run too many agents per process</li> <li>Monitor memory: Set limits and monitor usage</li> <li>Use thread pools: Prevent thread explosion</li> <li>Clean up resources: Properly shutdown agents and connections</li> </ul>"},{"location":"advanced-topics/multi-agent-processing/#2-communication-patterns","title":"2. Communication Patterns","text":"<ul> <li>Use discovery: Don't hardcode agent names</li> <li>Handle failures: Agents may come and go</li> <li>Implement timeouts: Prevent hanging requests</li> <li>Use circuit breakers: Protect against cascade failures</li> </ul>"},{"location":"advanced-topics/multi-agent-processing/#3-monitoring-and-debugging","title":"3. Monitoring and Debugging","text":"<ul> <li>Log extensively: Track agent interactions</li> <li>Use unique names: Include process/thread identifiers</li> <li>Monitor performance: Track request rates and response times</li> <li>Health checks: Implement agent health endpoints</li> </ul>"},{"location":"advanced-topics/multi-agent-processing/#4-testing-multi-agent-systems","title":"4. Testing Multi-Agent Systems","text":"<ul> <li>Integration tests: Test agent interactions</li> <li>Load testing: Test under realistic load</li> <li>Failure scenarios: Test agent failures and recovery</li> <li>Distributed tracing: Track requests across agents</li> </ul>"},{"location":"advanced-topics/multi-agent-processing/#next-steps","title":"Next Steps","text":"<ul> <li>Control Actions - Managing agent lifecycle</li> <li>Advanced Features - Dynamic loading and deployment</li> <li>Performance Considerations - Optimization strategies</li> </ul>"},{"location":"agent-development/custom-agent-implementation/","title":"Agent99 Framework","text":""},{"location":"agent-development/custom-agent-implementation/#custom-agent-implementation","title":"Custom Agent Implementation","text":""},{"location":"agent-development/custom-agent-implementation/#creating-a-custom-agent","title":"Creating a Custom Agent","text":"<p>To create a custom agent:</p> <ol> <li>Subclass <code>Agent99::Base</code>.</li> <li>Define the request and response schemas.</li> <li>Implement the <code>receive_request</code> and <code>receive_response</code> methods.</li> </ol> <p>Example:</p> <pre><code>class MyCustomAgent &lt; Agent99::Base\n  REQUEST_SCHEMA = MyAgentRequest.schema\n\n  def receive_request\n    # Handle incoming request\n    response = { result: \"Handled request\" }\n    send_response(response)\n  end\n\n  def receive_response\n    # Handle incoming response from another agent\n  end\nend\n</code></pre>"},{"location":"agent-development/error-handling-and-logging/","title":"Agent99 Framework","text":""},{"location":"agent-development/error-handling-and-logging/#error-handling-and-logging","title":"Error Handling and Logging","text":"<p>Agent99 incorporates robust error handling mechanisms, with error messages being captured and logged. The logging system is configured through environment variables to define the logging level and output destination.</p> <p>Example:</p> <pre><code>export LOG_LEVEL=DEBUG\n</code></pre> <p>Logs provide insights into agent activities, including errors encountered during message processing and system events.</p>"},{"location":"agent-development/request-response-handling/","title":"Request &amp; Response Handling","text":"<p>Understanding how to properly handle requests and responses is fundamental to building robust Agent99 applications. This guide covers patterns, best practices, and advanced techniques.</p>"},{"location":"agent-development/request-response-handling/#request-processing-lifecycle","title":"Request Processing Lifecycle","text":""},{"location":"agent-development/request-response-handling/#basic-request-handling","title":"Basic Request Handling","text":""},{"location":"agent-development/request-response-handling/#simple-request-processing","title":"Simple Request Processing","text":"<pre><code>class SimpleAgent &lt; Agent99::Base\n  def process_request(payload)\n    # Extract data from payload\n    user_name = payload.dig(:name) || \"Anonymous\"\n\n    # Perform business logic\n    greeting = generate_greeting(user_name)\n\n    # Send response\n    send_response(message: greeting)\n  end\n\n  private\n\n  def generate_greeting(name)\n    \"Hello, #{name}! Welcome to Agent99.\"\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#with-input-validation","title":"With Input Validation","text":"<pre><code>class ValidatingAgent &lt; Agent99::Base\n  def process_request(payload)\n    # Validate required fields\n    unless payload.key?(:user_id)\n      return send_error(\"Missing required field: user_id\", \"MISSING_FIELD\")\n    end\n\n    unless payload[:user_id].is_a?(String) &amp;&amp; !payload[:user_id].empty?\n      return send_error(\"Invalid user_id: must be non-empty string\", \"INVALID_FORMAT\")\n    end\n\n    # Process valid request\n    result = lookup_user_data(payload[:user_id])\n    send_response(result)\n  end\n\n  private\n\n  def lookup_user_data(user_id)\n    # Simulate database lookup\n    {\n      user_id: user_id,\n      name: \"User #{user_id}\",\n      status: \"active\",\n      last_seen: Time.now.iso8601\n    }\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#advanced-request-patterns","title":"Advanced Request Patterns","text":""},{"location":"agent-development/request-response-handling/#asynchronous-processing","title":"Asynchronous Processing","text":"<p>For long-running operations, acknowledge receipt immediately and process asynchronously:</p> <pre><code>class AsyncProcessingAgent &lt; Agent99::Base\n  def initialize\n    super\n    @job_queue = Queue.new\n    @worker_thread = Thread.new { process_jobs }\n  end\n\n  def process_request(payload)\n    job_id = SecureRandom.uuid\n\n    # Acknowledge receipt immediately\n    send_response(\n      status: \"accepted\",\n      job_id: job_id,\n      message: \"Request queued for processing\"\n    )\n\n    # Queue for background processing\n    @job_queue &lt;&lt; {\n      id: job_id,\n      payload: payload,\n      requester: current_request_id\n    }\n  end\n\n  private\n\n  def process_jobs\n    while job = @job_queue.pop\n      begin\n        result = perform_long_operation(job[:payload])\n\n        # Send completion notification (if supported)\n        notify_completion(job[:requester], job[:id], result)\n      rescue =&gt; e\n        logger.error \"Job #{job[:id]} failed: #{e.message}\"\n        notify_failure(job[:requester], job[:id], e.message)\n      end\n    end\n  end\n\n  def perform_long_operation(payload)\n    # Simulate long operation\n    sleep(5)\n    { result: \"Operation completed\", data: payload }\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#streaming-responses","title":"Streaming Responses","text":"<p>For data that comes in chunks:</p> <pre><code>class StreamingAgent &lt; Agent99::Base\n  def process_request(payload)\n    file_path = payload.dig(:file_path)\n\n    unless File.exist?(file_path)\n      return send_error(\"File not found: #{file_path}\", \"FILE_NOT_FOUND\")\n    end\n\n    # Send initial response\n    send_response(\n      status: \"streaming\",\n      total_size: File.size(file_path),\n      chunk_size: 1024\n    )\n\n    # Stream file contents\n    File.open(file_path, 'rb') do |file|\n      chunk_number = 0\n      while chunk = file.read(1024)\n        send_chunk(chunk_number, chunk)\n        chunk_number += 1\n      end\n    end\n\n    # Send completion marker\n    send_completion()\n  end\n\n  private\n\n  def send_chunk(number, data)\n    # Implementation depends on messaging system\n    # This is a conceptual example\n    publish_message({\n      type: \"chunk\",\n      sequence: number,\n      data: Base64.encode64(data)\n    })\n  end\n\n  def send_completion\n    publish_message({\n      type: \"stream_complete\"\n    })\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#response-patterns","title":"Response Patterns","text":""},{"location":"agent-development/request-response-handling/#success-responses","title":"Success Responses","text":"<pre><code># Simple success\nsend_response(result: \"Operation successful\")\n\n# Rich success response\nsend_response(\n  status: \"success\",\n  data: processed_data,\n  metadata: {\n    processing_time: elapsed_time,\n    version: \"1.0.0\"\n  }\n)\n\n# Collection response\nsend_response(\n  items: search_results,\n  total_count: total_count,\n  page: current_page,\n  has_more: has_more_pages\n)\n</code></pre>"},{"location":"agent-development/request-response-handling/#error-responses","title":"Error Responses","text":"<pre><code># Simple error\nsend_error(\"Something went wrong\")\n\n# Structured error\nsend_error(\"Invalid input data\", \"VALIDATION_ERROR\")\n\n# Rich error response\nsend_error(\n  \"Database connection failed\",\n  \"DATABASE_ERROR\",\n  {\n    retry_after: 30,\n    support_id: \"ERR-#{SecureRandom.hex(8)}\",\n    details: {\n      attempted_host: db_host,\n      timeout: connection_timeout\n    }\n  }\n)\n</code></pre>"},{"location":"agent-development/request-response-handling/#request-context-and-headers","title":"Request Context and Headers","text":""},{"location":"agent-development/request-response-handling/#accessing-request-headers","title":"Accessing Request Headers","text":"<pre><code>class HeaderAwareAgent &lt; Agent99::Base\n  def process_request(payload)\n    # Access headers from the current request\n    request_id = header_value('request_id')\n    user_id = header_value('user_id')\n    correlation_id = header_value('correlation_id')\n\n    logger.info \"Processing request #{request_id} for user #{user_id}\"\n\n    # Use headers in processing\n    if authorized_user?(user_id)\n      result = perform_operation(payload)\n      send_response(result)\n    else\n      send_error(\"Unauthorized access\", \"UNAUTHORIZED\")\n    end\n  end\n\n  private\n\n  def authorized_user?(user_id)\n    # Check authorization logic\n    user_id &amp;&amp; user_id.start_with?('user_')\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#setting-response-headers","title":"Setting Response Headers","text":"<pre><code>def process_request(payload)\n  result = process_data(payload)\n\n  # Set custom headers in response\n  set_header('processing_node', Socket.gethostname)\n  set_header('cache_status', 'miss')\n  set_header('processing_time', elapsed_time.to_s)\n\n  send_response(result)\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#error-handling-strategies","title":"Error Handling Strategies","text":""},{"location":"agent-development/request-response-handling/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>class ResilientAgent &lt; Agent99::Base\n  def process_request(payload)\n    begin\n      # Try primary service\n      result = primary_service.process(payload)\n      send_response(result)\n    rescue PrimaryServiceError =&gt; e\n      logger.warn \"Primary service failed: #{e.message}\"\n\n      begin\n        # Fallback to secondary service\n        result = secondary_service.process(payload)\n        result[:fallback_used] = true\n        send_response(result)\n      rescue SecondaryServiceError =&gt; e2\n        logger.error \"Both services failed: #{e2.message}\"\n\n        # Return cached or default result\n        default_result = get_cached_result(payload) || default_response\n        default_result[:degraded_service] = true\n        send_response(default_result)\n      end\n    end\n  end\n\n  private\n\n  def get_cached_result(payload)\n    # Check cache for previous result\n    cache_key = generate_cache_key(payload)\n    cached_data = cache.get(cache_key)\n\n    if cached_data &amp;&amp; fresh_enough?(cached_data)\n      cached_data[:from_cache] = true\n      return cached_data\n    end\n\n    nil\n  end\n\n  def default_response\n    {\n      status: \"service_unavailable\",\n      message: \"Service temporarily unavailable\",\n      retry_after: 60\n    }\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<pre><code>class CircuitBreakerAgent &lt; Agent99::Base\n  def initialize\n    super\n    @circuit_breaker = CircuitBreaker.new(\n      failure_threshold: 5,\n      recovery_timeout: 30\n    )\n  end\n\n  def process_request(payload)\n    @circuit_breaker.call do\n      # Potentially failing operation\n      external_service.process(payload)\n    end.then do |result|\n      send_response(result)\n    end.rescue do |error|\n      case error\n      when CircuitBreaker::OpenError\n        send_error(\"Service temporarily unavailable\", \"CIRCUIT_OPEN\")\n      else\n        send_error(\"Service error: #{error.message}\", \"SERVICE_ERROR\")\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#request-routing-and-delegation","title":"Request Routing and Delegation","text":""},{"location":"agent-development/request-response-handling/#multi-operation-agent","title":"Multi-operation Agent","text":"<pre><code>class MultiOperationAgent &lt; Agent99::Base\n  def process_request(payload)\n    operation = payload.dig(:operation)\n\n    case operation\n    when 'create'\n      handle_create(payload)\n    when 'read'\n      handle_read(payload)\n    when 'update'\n      handle_update(payload)\n    when 'delete'\n      handle_delete(payload)\n    else\n      send_error(\"Unknown operation: #{operation}\", \"INVALID_OPERATION\")\n    end\n  end\n\n  private\n\n  def handle_create(payload)\n    # Creation logic\n    entity = create_entity(payload[:data])\n    send_response(entity: entity, status: \"created\")\n  end\n\n  def handle_read(payload)\n    # Read logic\n    entity = find_entity(payload[:id])\n    if entity\n      send_response(entity: entity)\n    else\n      send_error(\"Entity not found\", \"NOT_FOUND\")\n    end\n  end\n\n  def handle_update(payload)\n    # Update logic\n    entity = update_entity(payload[:id], payload[:data])\n    send_response(entity: entity, status: \"updated\")\n  end\n\n  def handle_delete(payload)\n    # Delete logic\n    delete_entity(payload[:id])\n    send_response(status: \"deleted\")\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#testing-request-handling","title":"Testing Request Handling","text":""},{"location":"agent-development/request-response-handling/#unit-testing","title":"Unit Testing","text":"<pre><code>require 'minitest/autorun'\n\nclass TestCalculatorAgent &lt; Minitest::Test\n  def setup\n    @agent = CalculatorAgent.new\n  end\n\n  def test_successful_addition\n    payload = { operation: 'add', a: 5, b: 3 }\n\n    # Mock the send_response method\n    response = nil\n    @agent.stub(:send_response, -&gt;(data) { response = data }) do\n      @agent.process_request(payload)\n    end\n\n    assert_equal 8, response[:result]\n    assert_equal 'add', response[:operation]\n  end\n\n  def test_division_by_zero\n    payload = { operation: 'divide', a: 10, b: 0 }\n\n    error_response = nil\n    @agent.stub(:send_error, -&gt;(msg, code) { \n      error_response = { message: msg, code: code } \n    }) do\n      @agent.process_request(payload)\n    end\n\n    assert_equal 'DIVISION_BY_ZERO', error_response[:code]\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#best-practices","title":"Best Practices","text":""},{"location":"agent-development/request-response-handling/#dos","title":"Do's \u2705","text":"<ul> <li>Always respond: Every request should get a response</li> <li>Validate early: Check inputs before processing</li> <li>Use schemas: Define and validate request/response structures</li> <li>Log appropriately: Track requests without logging sensitive data</li> <li>Handle timeouts: Set reasonable processing time limits</li> <li>Provide context: Include helpful error messages and codes</li> </ul>"},{"location":"agent-development/request-response-handling/#donts","title":"Don'ts \u274c","text":"<ul> <li>Don't block indefinitely: Always have timeouts</li> <li>Don't expose internals: Keep error messages user-friendly</li> <li>Don't ignore errors: Handle and respond to all error conditions</li> <li>Don't trust input: Always validate and sanitize</li> <li>Don't forget correlation: Maintain request tracing across calls</li> </ul>"},{"location":"agent-development/request-response-handling/#performance-considerations","title":"Performance Considerations","text":""},{"location":"agent-development/request-response-handling/#memory-management","title":"Memory Management","text":"<pre><code>def process_request(payload)\n  # Stream large data instead of loading all at once\n  if payload[:data_size] &gt; LARGE_DATA_THRESHOLD\n    process_data_streaming(payload)\n  else\n    process_data_in_memory(payload)\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#connection-pooling","title":"Connection Pooling","text":"<pre><code>class DatabaseAgent &lt; Agent99::Base\n  def initialize\n    super\n    @connection_pool = ConnectionPool.new(size: 10) do\n      Database.connect\n    end\n  end\n\n  def process_request(payload)\n    @connection_pool.with do |connection|\n      result = connection.query(payload[:sql])\n      send_response(rows: result.to_a)\n    end\n  end\nend\n</code></pre>"},{"location":"agent-development/request-response-handling/#next-steps","title":"Next Steps","text":"<ul> <li>Error Handling &amp; Logging - Comprehensive error strategies</li> <li>Schema Definition - Advanced schema patterns  </li> <li>Advanced Features - Complex patterns and techniques</li> </ul>"},{"location":"agent-development/schema-definition/","title":"Agent99 Framework","text":""},{"location":"agent-development/schema-definition/#schema-definition","title":"Schema Definition","text":"<p>Agent99 uses <code>SimpleJsonSchemaBuilder</code> for defining message schemas. This gem was chosen for its Ruby-like DSL that makes schema definitions readable and maintainable, while still producing JSON Schema compatible output.</p>"},{"location":"agent-development/schema-definition/#header-schema","title":"Header Schema","text":"<p>All messages in Agent99 must include a header that conforms to this schema:</p> <pre><code>class Agent99::HeaderSchema &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    string :type,       required: true, \n                          enum: %w[request response control]\n    string  :to_uuid,   required: true\n    string  :from_uuid, required: true\n    string  :event_uuid,required: true\n    integer :timestamp, required: true\n  end\nend\n</code></pre>"},{"location":"agent-development/schema-definition/#request-schema-example","title":"Request Schema Example","text":"<p>Define your agent's request schema by inheriting from SimpleJsonSchemaBuilder::Base:</p> <pre><code>class MyAgentRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n    string :greeting, required: false,  examples: [\"Hello\"]\n    string :name,     required: true,   examples: [\"World\"]\n  end\nend\n</code></pre> <p>In this example, the agent has two parameters that it uses from the request message: greeting and name; however, greeting is not required.  The Agent99 framework will use the first item in the examples array as a default for optional parameters.</p>"},{"location":"agent-development/schema-definition/#automatic-schema-validation","title":"Automatic Schema Validation","text":"<p>Agent99 automatically validates incoming request messages against your agent's REQUEST_SCHEMA:</p> <ol> <li>When a request arrives, the framework checks if your agent class defines REQUEST_SCHEMA</li> <li>If defined, the message is validated before reaching your receive_request method</li> <li>If validation fails:</li> <li>An error response is automatically sent back to the requester</li> <li>Your receive_request method is not called</li> <li>The validation errors are logged</li> </ol> <p>Example validation error response:</p> <pre><code>{\n  header: {\n    type:       'error',\n    to_uuid:    original_from_uuid,\n    from_uuid:  agent_id,\n    event_uuid: original_event_uuid,\n    timestamp:  current_timestamp\n  },\n  errors: ['Required property \"name\" not found in request']\n}\n</code></pre>"},{"location":"agent-development/schema-definition/#why-simplejsonschemabuilder","title":"Why SimpleJsonSchemaBuilder?","text":"<p>SimpleJsonSchemaBuilder was chosen for Agent99 because it:</p> <ol> <li>Provides a Ruby-native DSL for schema definition</li> <li>Generates standard JSON Schema output</li> <li>Supports schema composition and reuse</li> <li>Includes built-in validation</li> <li>Has excellent performance characteristics</li> <li>Maintains type safety through static analysis</li> </ol> <p>The gem allows us to define schemas that are both human-readable and machine-validatable, while staying within the Ruby ecosystem.</p>"},{"location":"agent99_framework/central_registry/","title":"Central Registry","text":""},{"location":"agent99_framework/central_registry/#overview","title":"Overview","text":"<p>The Central Registry is a crucial component of the Agent99 Framework, serving as a centralized hub for agent registration, discovery, and management. Its primary purpose is to facilitate communication and coordination between various agents within the framework, allowing them to register their capabilities and discover other agents with specific skills.</p> <p>The registry provides a RESTful API that can be implemented in any programming language or web framework that supports HTTPS endpoints. This document outlines the API specifications for implementing a compatible Central Registry.</p>"},{"location":"agent99_framework/central_registry/#api-endpoints","title":"API Endpoints","text":""},{"location":"agent99_framework/central_registry/#1-health-check","title":"1. Health Check","text":"<ul> <li>Endpoint: GET /healthcheck</li> <li>Purpose: Provides a simple health check for the registry service.</li> <li>Response: JSON object containing the current count of registered agents.</li> <li>Example Response:   <pre><code>{\n  \"agent_count\": 5\n}\n</code></pre></li> </ul>"},{"location":"agent99_framework/central_registry/#2-register-agent","title":"2. Register Agent","text":"<ul> <li>Endpoint: POST /register</li> <li>Purpose: Allows an agent to register itself with the registry, providing its name and capabilities.</li> <li>Request Body: JSON object containing agent information.</li> <li>Response: JSON object with a newly generated UUID for the registered agent.</li> <li>Example Request:   <pre><code>{\n  \"name\": \"TextAnalyzer\",\n  \"capabilities\": [\"sentiment analysis\", \"named entity recognition\"]\n}\n</code></pre></li> <li>Example Response:   <pre><code>{\n  \"uuid\": \"550e8400-e29b-41d4-a716-446655440000\"\n}\n</code></pre></li> </ul>"},{"location":"agent99_framework/central_registry/#3-discover-agents","title":"3. Discover Agents","text":"<ul> <li>Endpoint: GET /discover</li> <li>Purpose: Allows discovery of agents based on a specific capability.</li> <li>Query Parameter: capability (string)</li> <li>Response: JSON array of matching agents with their full information.</li> <li>Example Request: GET /discover?capability=sentiment+analysis</li> <li>Example Response:   <pre><code>[\n  {\n    \"name\": \"TextAnalyzer\",\n    \"capabilities\": [\"sentiment analysis\", \"named entity recognition\"],\n    \"uuid\": \"550e8400-e29b-41d4-a716-446655440000\"\n  }\n]\n</code></pre></li> </ul>"},{"location":"agent99_framework/central_registry/#4-withdraw-agent","title":"4. Withdraw Agent","text":"<ul> <li>Endpoint: DELETE /withdraw/:uuid</li> <li>Purpose: Removes an agent from the registry using its UUID.</li> <li>Response: </li> <li>204 No Content if successful</li> <li>404 Not Found if the agent UUID is not in the registry</li> <li>Example Request: DELETE /withdraw/550e8400-e29b-41d4-a716-446655440000</li> </ul>"},{"location":"agent99_framework/central_registry/#5-list-all-agents","title":"5. List All Agents","text":"<ul> <li>Endpoint: GET /</li> <li>Purpose: Retrieves a list of all registered agents.</li> <li>Response: JSON array containing all registered agents' information.</li> </ul>"},{"location":"agent99_framework/central_registry/#implementation-notes","title":"Implementation Notes","text":"<ol> <li>Agent capabilities should be stored and compared in lowercase to ensure case-insensitive matching.</li> <li>The current implementation uses an in-memory array to store agent information. For production use, consider using a persistent database like SQLite or a more scalable solution.</li> <li>The discovery process currently uses simple keyword matching. Future enhancements could include semantic matching for more accurate agent discovery.</li> </ol>"},{"location":"agent99_framework/central_registry/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>Persistent Storage: Implement a database backend for storing agent information, ensuring data persistence across server restarts.</li> <li>Authentication and Authorization: Add security measures to protect sensitive endpoints and ensure only authorized agents can register or withdraw.</li> <li>Semantic Matching: Enhance the discovery process with natural language processing or vector search capabilities for more intelligent agent matching.</li> <li>Agent Health Monitoring: Implement periodic health checks on registered agents to ensure they are still active and available.</li> <li>Versioning: Add support for agent versioning to manage different versions of agents with similar capabilities.</li> <li>Pagination: Implement pagination for the discovery and list all endpoints to handle large numbers of agents efficiently.</li> <li>Metrics and Logging: Add comprehensive logging and metrics collection for better monitoring and debugging of the registry service.</li> <li>API Rate Limiting: Implement rate limiting to prevent abuse and ensure fair usage of the registry service.</li> </ol> <p>By implementing this API, developers can create a compatible Central Registry for the Agent99 Framework in their preferred language or framework, enabling seamless integration and communication between diverse agents in the ecosystem.</p>"},{"location":"agent99_framework/message_client/","title":"Message Client Documentation for Agent99 Framework","text":""},{"location":"agent99_framework/message_client/#overview","title":"Overview","text":"<p>The Message Client is a crucial component of the Agent99 Framework, providing an interface for agents to communicate with each other through a message broker. This document outlines the required methods and functionalities that should be implemented in any message client to ensure compatibility with the Agent99 Framework.</p>"},{"location":"agent99_framework/message_client/#message-format-requirements","title":"Message Format Requirements","text":"<p>All messages sent and received through the Agent99 Framework must adhere to the following format requirements:</p> <ol> <li> <p>JSON Format: All messages must be in JSON format. This ensures consistency and ease of parsing across different implementations and languages.</p> </li> <li> <p>Header Element: Each message must include a <code>header</code> element that conforms to the <code>HeaderSchema</code> defined for the Agent99 Framework. The <code>HeaderSchema</code> is as follows:</p> </li> </ol> <pre><code>class Agent99::HeaderSchema &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    string  :from_uuid,   required: true, examples: [SecureRandom.uuid]\n    string  :to_uuid,     required: true, examples: [SecureRandom.uuid]\n    string  :event_uuid,  required: true, examples: [SecureRandom.uuid]\n    string  :type,        required: true, examples: %w[request response control]\n    integer :timestamp,   required: true, examples: [Agent99::Timestamp.new.to_i]\n  end\nend\n</code></pre> <ol> <li> <p>Message Types: The <code>type</code> field in the header must be one of: <code>request</code>, <code>response</code>, or <code>control</code>.</p> </li> <li> <p>Validation: All incoming messages are validated against the appropriate schema based on their type. If validation errors are found, an error response message is returned to the sender.</p> </li> </ol>"},{"location":"agent99_framework/message_client/#class-messageclient","title":"Class: MessageClient","text":""},{"location":"agent99_framework/message_client/#initialization","title":"Initialization","text":"<pre><code>def initialize(config: {}, logger: Logger.new($stdout))\n  # Implementation details...\nend\n</code></pre> <p>Creates a new instance of the MessageClient.</p> <ul> <li><code>config:</code> A hash containing configuration options for the message broker connection.</li> <li><code>logger:</code> A logger instance for output (default: stdout logger).</li> </ul>"},{"location":"agent99_framework/message_client/#public-methods","title":"Public Methods","text":""},{"location":"agent99_framework/message_client/#setup","title":"setup","text":"<pre><code>def setup(agent_id:, logger:)\n  # Implementation details...\nend\n</code></pre> <p>Sets up the necessary resources for an agent to start communicating.</p> <ul> <li><code>agent_id:</code> The unique identifier for the agent.</li> <li><code>logger:</code> A logger instance for output.</li> <li>Returns: An object representing the agent's message queue or channel.</li> </ul>"},{"location":"agent99_framework/message_client/#listen_for_messages","title":"listen_for_messages","text":"<pre><code>def listen_for_messages(\n  queue,\n  request_handler:,\n  response_handler:,\n  control_handler:\n)\n  # Implementation details...\nend\n</code></pre> <p>Starts listening for incoming messages on the specified queue.</p> <ul> <li><code>queue:</code> The queue or channel object returned by the <code>setup</code> method.</li> <li><code>request_handler:</code> A callable object to handle incoming request messages.</li> <li><code>response_handler:</code> A callable object to handle incoming response messages.</li> <li><code>control_handler:</code> A callable object to handle incoming control messages.</li> </ul>"},{"location":"agent99_framework/message_client/#publish","title":"publish","text":"<pre><code>def publish(message:)\n  # Implementation details...\nend\n</code></pre> <p>Publishes a message to the specified queue.</p> <ul> <li><code>message:</code> A hash containing the message to be published. This must be in JSON format and include a header that conforms to the <code>HeaderSchema</code>.</li> <li>Returns: A hash indicating the success or failure of the publish operation, including details if the message structure is invalid.</li> </ul>"},{"location":"agent99_framework/message_client/#delete_queue","title":"delete_queue","text":"<pre><code>def delete_queue(queue_name:)\n  # Implementation details...\nend\n</code></pre> <p>Deletes the specified queue or cleans up resources associated with it.</p> <ul> <li><code>queue_name:</code> The name of the queue to be deleted.</li> </ul>"},{"location":"agent99_framework/message_client/#implementation-notes","title":"Implementation Notes","text":"<ol> <li> <p>Message Validation: Implement thorough validation for all incoming and outgoing messages. Ensure that they are in JSON format and contain a header that conforms to the <code>HeaderSchema</code>. If validation fails for incoming messages, send an error response to the sender with details about the validation issues.</p> </li> <li> <p>Error Handling: Implement robust error handling for all methods, especially for connection, publishing, and validation errors.</p> </li> <li> <p>Logging: Provide detailed logging for all operations, including successful actions, validation results, and errors.</p> </li> <li> <p>Performance and Scalability: Optimize the client to handle a large number of JSON-formatted messages efficiently, considering potential performance impacts of validation.</p> </li> <li> <p>Thread Safety: Ensure that the client is thread-safe, particularly when handling message validation and publishing.</p> </li> </ol> <p>By adhering to these requirements and implementing the MessageClient with these considerations, developers can ensure that their implementations will be fully compatible with the Agent99 Framework. The strict adherence to JSON formatting and the inclusion of a standardized header in all messages promotes consistency and reliability in inter-agent communication within the framework.</p>"},{"location":"agent99_framework/registry_client/","title":"RegistryClient Documentation","text":""},{"location":"agent99_framework/registry_client/#overview","title":"Overview","text":"<p>The RegistryClient class is a crucial component of the Agent99 framework, providing a Ruby interface to interact with the Central Registry service. It encapsulates the HTTP communication logic required to register agents, discover capabilities, and manage agent lifecycle within the Agent99 ecosystem.</p>"},{"location":"agent99_framework/registry_client/#class-agent99registryclient","title":"Class: Agent99::RegistryClient","text":""},{"location":"agent99_framework/registry_client/#initialization","title":"Initialization","text":"<pre><code>def initialize(base_url: ENV.fetch('REGISTRY_BASE_URL', 'http://localhost:4567'),\n               logger: Logger.new($stdout))\n</code></pre> <p>Creates a new instance of the RegistryClient.</p> <ul> <li><code>base_url</code>: The URL of the Central Registry service (default: http://localhost:4567)</li> <li><code>logger</code>: A logger instance for output (default: stdout logger)</li> </ul>"},{"location":"agent99_framework/registry_client/#public-methods","title":"Public Methods","text":""},{"location":"agent99_framework/registry_client/#register","title":"register","text":"<pre><code>def register(name:, capabilities:)\n</code></pre> <p>Registers an agent with the Central Registry.</p> <ul> <li><code>name</code>: The name of the agent</li> <li><code>capabilities</code>: An array of capabilities the agent possesses</li> <li>Returns: The UUID of the registered agent</li> </ul> <p>One of the first improvement that should be considered when registering a new agent is adding its JSON schema for its request and response messages.  This way there should be no question about how to interface with the agent.</p>"},{"location":"agent99_framework/registry_client/#withdraw","title":"withdraw","text":"<pre><code>def withdraw(id)\n</code></pre> <p>Withdraws an agent from the Central Registry.</p> <ul> <li><code>id</code>: The UUID of the agent to withdraw</li> <li>Returns: nil</li> </ul>"},{"location":"agent99_framework/registry_client/#discover","title":"discover","text":"<pre><code>def discover(capability:)\n</code></pre> <p>Discovers agents with a specific capability.</p> <ul> <li><code>capability</code>: The capability to search for</li> <li>Returns: An array of agents matching the capability</li> </ul>"},{"location":"agent99_framework/registry_client/#fetch_all_agents","title":"fetch_all_agents","text":"<pre><code>def fetch_all_agents\n</code></pre> <p>Retrieves all registered agents from the Central Registry.</p> <ul> <li>Returns: An array of all registered agents</li> </ul>"},{"location":"agent99_framework/registry_client/#private-methods","title":"Private Methods","text":"<p>The class includes several private methods for handling HTTP requests and responses:</p> <ul> <li><code>create_request</code>: Creates an HTTP request object</li> <li><code>send_request</code>: Sends an HTTP request and handles exceptions</li> <li><code>handle_response</code>: Processes the HTTP response based on its status code</li> </ul>"},{"location":"agent99_framework/registry_client/#usage-example","title":"Usage Example","text":"<pre><code>client = Agent99::RegistryClient.new\nagent_id = client.register(name: \"TextAnalyzer\", capabilities: [\"sentiment analysis\", \"named entity recognition\"])\nmatching_agents = client.discover(capability: \"sentiment analysis\")\nclient.withdraw(agent_id)\n</code></pre>"},{"location":"agent99_framework/registry_client/#potential-improvements","title":"Potential Improvements","text":"<ol> <li> <p>Error Handling: Implement more granular error handling and custom exceptions for different types of failures (e.g., network errors, authentication errors).</p> </li> <li> <p>Retry Mechanism: Add a retry mechanism for transient failures, potentially using a library like <code>retriable</code>.</p> </li> <li> <p>Connection Pooling: Implement connection pooling to improve performance when making multiple requests.</p> </li> <li> <p>Caching: Add caching for frequently accessed data, such as the list of all agents or common capability searches.</p> </li> <li> <p>Asynchronous Operations: Provide asynchronous versions of methods for non-blocking operations, possibly using Ruby's <code>async</code>/<code>await</code> syntax or a library like <code>concurrent-ruby</code>.</p> </li> <li> <p>Pagination Support: Implement pagination for methods that return potentially large datasets, such as <code>fetch_all_agents</code>.</p> </li> <li> <p>Capability Normalization: Normalize capabilities (e.g., lowercase, remove whitespace) before sending to ensure consistent matching.</p> </li> <li> <p>Batch Operations: Add support for batch registration or withdrawal of multiple agents in a single request.</p> </li> <li> <p>Logging Enhancements: Improve logging to include more detailed information about requests and responses for better debugging.</p> </li> <li> <p>Configuration Options: Allow more configuration options, such as timeout settings, custom headers, or SSL/TLS options.</p> </li> <li> <p>Capability Validation: Implement client-side validation of capabilities before sending requests to the server.</p> </li> <li> <p>Agent Status Updates: Add methods to update an agent's status or capabilities without full re-registration.</p> </li> <li> <p>Metrics Collection: Integrate with a metrics library to collect and report on API usage and performance.</p> </li> <li> <p>Authentication Support: Add support for authentication mechanisms if the Central Registry implements them in the future.</p> </li> <li> <p>API Versioning: Implement support for API versioning to handle potential future changes in the Central Registry API.</p> </li> </ol> <p>By implementing these improvements, the RegistryClient can become more robust, efficient, and feature-rich, enhancing its utility within the Agent99 framework.</p>"},{"location":"api-reference/agent99-base/","title":"Agent99::Base","text":"<p>The <code>Agent99::Base</code> class is the foundation of all agents in the Agent99 framework. It provides core functionality for agent lifecycle, messaging, discovery, and error handling.</p>"},{"location":"api-reference/agent99-base/#class-overview","title":"Class Overview","text":"<pre><code>class Agent99::Base\n  include Agent99::HeaderManagement\n  include Agent99::AgentDiscovery  \n  include Agent99::ControlActions\n  include Agent99::AgentLifecycle\n  include Agent99::MessageProcessing\nend\n</code></pre>"},{"location":"api-reference/agent99-base/#instance-methods","title":"Instance Methods","text":""},{"location":"api-reference/agent99-base/#core-lifecycle","title":"Core Lifecycle","text":""},{"location":"api-reference/agent99-base/#run","title":"<code>#run</code>","text":"<p>Starts the agent and begins listening for messages.</p> <pre><code>def run\n</code></pre> <p>Example: <pre><code>agent = MyAgent.new\nagent.run  # Blocks until shutdown\n</code></pre></p>"},{"location":"api-reference/agent99-base/#shutdown","title":"<code>#shutdown</code>","text":"<p>Gracefully shuts down the agent.</p> <pre><code>def shutdown\n</code></pre> <p>Example: <pre><code>agent.shutdown\n</code></pre></p>"},{"location":"api-reference/agent99-base/#info","title":"<code>#info</code>","text":"<p>Abstract method that must be implemented by subclasses. Returns agent metadata.</p> <pre><code>def info\n  # Must return hash with:\n  # - :name (String)\n  # - :type (Symbol: :server, :client, or :hybrid)  \n  # - :capabilities (Array of Strings)\nend\n</code></pre> <p>Example: <pre><code>def info\n  {\n    name: self.class.to_s,\n    type: :server,\n    capabilities: ['calculator', 'math']\n  }\nend\n</code></pre></p>"},{"location":"api-reference/agent99-base/#message-processing","title":"Message Processing","text":""},{"location":"api-reference/agent99-base/#process_requestpayload","title":"<code>#process_request(payload)</code>","text":"<p>Abstract method for handling incoming requests. Only called for server and hybrid agents.</p> <pre><code>def process_request(payload)\n  # Process the payload and call send_response or send_error\nend\n</code></pre> <p>Parameters: - <code>payload</code> (Hash) - The request data</p> <p>Example: <pre><code>def process_request(payload)\n  name = payload.dig(:name) || \"World\"\n  send_response(message: \"Hello, #{name}!\")\nend\n</code></pre></p>"},{"location":"api-reference/agent99-base/#send_responsedata","title":"<code>#send_response(data)</code>","text":"<p>Sends a successful response back to the requester.</p> <pre><code>def send_response(data)\n</code></pre> <p>Parameters: - <code>data</code> (Hash) - Response data</p> <p>Example: <pre><code>send_response(\n  result: 42,\n  status: \"success\",\n  timestamp: Time.now.iso8601\n)\n</code></pre></p>"},{"location":"api-reference/agent99-base/#send_errormessage-code-nil-details-nil","title":"<code>#send_error(message, code = nil, details = nil)</code>","text":"<p>Sends an error response back to the requester.</p> <pre><code>def send_error(message, code = nil, details = nil)\n</code></pre> <p>Parameters: - <code>message</code> (String) - Error message - <code>code</code> (String, optional) - Error code - <code>details</code> (Hash, optional) - Additional error details</p> <p>Example: <pre><code>send_error(\n  \"Invalid input data\", \n  \"VALIDATION_ERROR\",\n  { field: \"email\", expected: \"valid email address\" }\n)\n</code></pre></p>"},{"location":"api-reference/agent99-base/#send_requestagent_name-payload-options","title":"<code>#send_request(agent_name, payload, options = {})</code>","text":"<p>Sends a request to another agent. Only available for client and hybrid agents.</p> <pre><code>def send_request(agent_name, payload, options = {})\n</code></pre> <p>Parameters: - <code>agent_name</code> (String) - Target agent name - <code>payload</code> (Hash) - Request data - <code>options</code> (Hash, optional) - Request options (timeout, etc.)</p> <p>Returns: Response hash or nil if failed</p> <p>Example: <pre><code>response = send_request(\n  \"CalculatorAgent\", \n  { operation: \"add\", a: 5, b: 3 },\n  { timeout: 30 }\n)\n</code></pre></p>"},{"location":"api-reference/agent99-base/#agent-discovery","title":"Agent Discovery","text":""},{"location":"api-reference/agent99-base/#discover_agentscapabilities","title":"<code>#discover_agents(capabilities = [])</code>","text":"<p>Finds agents that match the specified capabilities.</p> <pre><code>def discover_agents(capabilities = [])\n</code></pre> <p>Parameters: - <code>capabilities</code> (Array) - List of required capabilities</p> <p>Returns: Array of agent info hashes</p> <p>Example: <pre><code>calculators = discover_agents(['calculator'])\nweather_agents = discover_agents(['weather', 'forecast'])\n</code></pre></p>"},{"location":"api-reference/agent99-base/#register_agent","title":"<code>#register_agent</code>","text":"<p>Registers this agent with the registry.</p> <pre><code>def register_agent\n</code></pre> <p>Example: <pre><code>register_agent\n</code></pre></p>"},{"location":"api-reference/agent99-base/#unregister_agent","title":"<code>#unregister_agent</code>","text":"<p>Removes this agent from the registry.</p> <pre><code>def unregister_agent\n</code></pre>"},{"location":"api-reference/agent99-base/#header-management","title":"Header Management","text":""},{"location":"api-reference/agent99-base/#header_valuekey","title":"<code>#header_value(key)</code>","text":"<p>Gets a header value from the current request.</p> <pre><code>def header_value(key)\n</code></pre> <p>Parameters: - <code>key</code> (String) - Header key</p> <p>Returns: Header value or nil</p> <p>Example: <pre><code>user_id = header_value('user_id')\ncorrelation_id = header_value('correlation_id')\n</code></pre></p>"},{"location":"api-reference/agent99-base/#set_headerkey-value","title":"<code>#set_header(key, value)</code>","text":"<p>Sets a header value for the current response.</p> <pre><code>def set_header(key, value)\n</code></pre> <p>Parameters: - <code>key</code> (String) - Header key - <code>value</code> (String) - Header value</p> <p>Example: <pre><code>set_header('processing_time', '150ms')\nset_header('cache_status', 'hit')\n</code></pre></p>"},{"location":"api-reference/agent99-base/#control-actions","title":"Control Actions","text":""},{"location":"api-reference/agent99-base/#pause","title":"<code>#pause</code>","text":"<p>Pauses the agent (stops processing new requests).</p> <pre><code>def pause\n</code></pre>"},{"location":"api-reference/agent99-base/#resume","title":"<code>#resume</code>","text":"<p>Resumes the agent after being paused.</p> <pre><code>def resume\n</code></pre>"},{"location":"api-reference/agent99-base/#status","title":"<code>#status</code>","text":"<p>Returns the current agent status.</p> <pre><code>def status\n</code></pre> <p>Returns: Symbol (<code>:running</code>, <code>:paused</code>, <code>:stopped</code>)</p>"},{"location":"api-reference/agent99-base/#configuration","title":"Configuration","text":""},{"location":"api-reference/agent99-base/#logger","title":"<code>#logger</code>","text":"<p>Returns the logger instance for this agent.</p> <pre><code>def logger\n</code></pre> <p>Example: <pre><code>logger.info \"Processing request\"\nlogger.error \"Something went wrong: #{error.message}\"\n</code></pre></p>"},{"location":"api-reference/agent99-base/#config","title":"<code>#config</code>","text":"<p>Returns the configuration hash for this agent.</p> <pre><code>def config\n</code></pre> <p>Example: <pre><code>timeout = config[:timeout] || 30\nregistry_url = config[:registry_url]\n</code></pre></p>"},{"location":"api-reference/agent99-base/#class-methods","title":"Class Methods","text":""},{"location":"api-reference/agent99-base/#agent99basecreatetype-options","title":"<code>Agent99::Base.create(type:, **options)</code>","text":"<p>Factory method for creating agents.</p> <pre><code>Agent99::Base.create(type: :server, name: 'TestAgent')\n</code></pre> <p>Parameters: - <code>type</code> (Symbol) - Agent type (<code>:server</code>, <code>:client</code>, <code>:hybrid</code>) - <code>options</code> (Hash) - Configuration options</p>"},{"location":"api-reference/agent99-base/#configuration-options","title":"Configuration Options","text":"<p>When creating agents, you can pass configuration options:</p> <pre><code>class MyAgent &lt; Agent99::Base\n  def initialize(options = {})\n    super(options)\n  end\nend\n\nagent = MyAgent.new(\n  registry_url: 'http://localhost:4567',\n  message_client: 'nats',\n  timeout: 30,\n  log_level: :info\n)\n</code></pre>"},{"location":"api-reference/agent99-base/#available-options","title":"Available Options","text":"Option Type Default Description <code>registry_url</code> String <code>http://localhost:4567</code> Registry service URL <code>message_client</code> String <code>nats</code> Message broker type (<code>nats</code>, <code>amqp</code>, <code>tcp</code>) <code>timeout</code> Integer 30 Default request timeout (seconds) <code>log_level</code> Symbol <code>:info</code> Logging level <code>retry_attempts</code> Integer 3 Request retry attempts <code>retry_delay</code> Integer 1 Delay between retries (seconds)"},{"location":"api-reference/agent99-base/#examples","title":"Examples","text":""},{"location":"api-reference/agent99-base/#simple-server-agent","title":"Simple Server Agent","text":"<pre><code>class GreeterAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['greeting', 'hello']\n    }\n  end\n\n  def process_request(payload)\n    name = payload.dig(:name) || \"World\"\n    logger.info \"Greeting #{name}\"\n\n    send_response(\n      message: \"Hello, #{name}!\",\n      timestamp: Time.now.iso8601\n    )\n  end\nend\n</code></pre>"},{"location":"api-reference/agent99-base/#client-agent-with-error-handling","title":"Client Agent with Error Handling","text":"<pre><code>class ClientAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :client,\n      capabilities: ['client_operations']\n    }\n  end\n\n  def make_greeting_request(name)\n    greeters = discover_agents(['greeting'])\n\n    if greeters.empty?\n      logger.warn \"No greeting agents available\"\n      return nil\n    end\n\n    begin\n      response = send_request(\n        greeters.first[:name], \n        { name: name },\n        { timeout: 10 }\n      )\n\n      logger.info \"Received: #{response[:message]}\"\n      response\n    rescue =&gt; e\n      logger.error \"Request failed: #{e.message}\"\n      nil\n    end\n  end\nend\n</code></pre>"},{"location":"api-reference/agent99-base/#hybrid-agent-with-state","title":"Hybrid Agent with State","text":"<pre><code>class StatefulAgent &lt; Agent99::Base\n  def initialize(options = {})\n    super(options)\n    @request_count = 0\n    @mutex = Mutex.new\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :hybrid,\n      capabilities: ['stateful', 'counter']\n    }\n  end\n\n  def process_request(payload)\n    @mutex.synchronize do\n      @request_count += 1\n\n      if payload[:operation] == 'get_count'\n        send_response(count: @request_count)\n      elsif payload[:operation] == 'reset_count'\n        @request_count = 0\n        send_response(count: 0, status: 'reset')\n      else\n        send_error('Unknown operation', 'INVALID_OPERATION')\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"api-reference/agent99-base/#thread-safety","title":"Thread Safety","text":"<p>The <code>Agent99::Base</code> class is designed to be thread-safe for concurrent request processing. However:</p> <ul> <li>Subclass implementations should ensure thread safety in their <code>process_request</code> methods</li> <li>Shared state should be protected with mutexes or other synchronization primitives  </li> <li>Instance variables may be accessed concurrently during request processing</li> </ul>"},{"location":"api-reference/agent99-base/#error-handling","title":"Error Handling","text":"<p>The base class provides automatic error handling for:</p> <ul> <li>Network failures during agent registration and discovery</li> <li>Message broker disconnections with automatic retry</li> <li>Invalid message formats with appropriate error responses</li> <li>Unhandled exceptions in <code>process_request</code> (converted to error responses)</li> </ul>"},{"location":"api-reference/agent99-base/#next-steps","title":"Next Steps","text":"<ul> <li>Registry Client - Registry service API</li> <li>Message Clients - Message broker clients</li> <li>Schemas - Schema validation system</li> </ul>"},{"location":"api-reference/message-clients/","title":"Message Clients API","text":"<p>Agent99 supports multiple message broker clients for different messaging protocols. This document covers the APIs and configuration for each supported client type.</p>"},{"location":"api-reference/message-clients/#overview","title":"Overview","text":"<p>Agent99 currently supports three message client types:</p> <ul> <li>NATS - High-performance, cloud-native messaging (recommended)</li> <li>AMQP - Advanced Message Queuing Protocol via RabbitMQ</li> <li>TCP - Simple TCP-based messaging for testing</li> </ul>"},{"location":"api-reference/message-clients/#client-selection","title":"Client Selection","text":"<p>The message client is automatically selected based on configuration:</p> <pre><code># Environment variable\nENV['AGENT99_MESSAGE_CLIENT'] = 'nats'  # or 'amqp', 'tcp'\n\n# Or via agent initialization\nagent = MyAgent.new(message_client: 'nats')\n</code></pre>"},{"location":"api-reference/message-clients/#nats-client","title":"NATS Client","text":""},{"location":"api-reference/message-clients/#configuration","title":"Configuration","text":"<pre><code># Environment variables\nENV['NATS_URL'] = 'nats://localhost:4222'\nENV['NATS_USERNAME'] = 'agent99'      # optional\nENV['NATS_PASSWORD'] = 'secret'       # optional\n\n# Or programmatically\nnats_config = {\n  servers: ['nats://localhost:4222'],\n  username: 'agent99',\n  password: 'secret',\n  timeout: 30,\n  reconnect_attempts: 10\n}\n\nclient = Agent99::MessageClients::NatsClient.new(nats_config)\n</code></pre>"},{"location":"api-reference/message-clients/#connection-options","title":"Connection Options","text":"Option Type Default Description <code>servers</code> Array <code>['nats://localhost:4222']</code> NATS server URLs <code>username</code> String <code>nil</code> Authentication username <code>password</code> String <code>nil</code> Authentication password <code>timeout</code> Integer 30 Connection timeout (seconds) <code>reconnect_attempts</code> Integer 10 Reconnection attempts <code>max_reconnect_attempts</code> Integer -1 Max reconnection attempts (-1 = unlimited)"},{"location":"api-reference/message-clients/#usage-example","title":"Usage Example","text":"<pre><code>class NatsAgent &lt; Agent99::Base\n  def initialize\n    super(message_client: 'nats')\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['nats_example']\n    }\n  end\n\n  def process_request(payload)\n    # NATS-specific features can be accessed via client\n    subject = current_message_subject\n    reply_to = current_reply_subject\n\n    logger.info \"Received on subject: #{subject}\"\n\n    send_response(\n      message: \"Processed via NATS\",\n      subject: subject,\n      timestamp: Time.now.iso8601\n    )\n  end\nend\n</code></pre>"},{"location":"api-reference/message-clients/#amqp-client-rabbitmq","title":"AMQP Client (RabbitMQ)","text":""},{"location":"api-reference/message-clients/#configuration_1","title":"Configuration","text":"<pre><code># Environment variables\nENV['RABBITMQ_URL'] = 'amqp://localhost:5672'\nENV['RABBITMQ_USERNAME'] = 'guest'    # optional\nENV['RABBITMQ_PASSWORD'] = 'guest'    # optional\n\n# Or programmatically\namqp_config = {\n  url: 'amqp://localhost:5672',\n  username: 'agent99',\n  password: 'secret',\n  vhost: '/',\n  timeout: 30,\n  heartbeat: 30\n}\n\nclient = Agent99::MessageClients::AmqpClient.new(amqp_config)\n</code></pre>"},{"location":"api-reference/message-clients/#connection-options_1","title":"Connection Options","text":"Option Type Default Description <code>url</code> String <code>amqp://localhost:5672</code> RabbitMQ connection URL <code>username</code> String <code>guest</code> Authentication username <code>password</code> String <code>guest</code> Authentication password <code>vhost</code> String <code>/</code> Virtual host <code>timeout</code> Integer 30 Connection timeout (seconds) <code>heartbeat</code> Integer 30 Heartbeat interval (seconds) <code>exchange</code> String <code>agent99</code> Default exchange name <code>exchange_type</code> String <code>topic</code> Exchange type"},{"location":"api-reference/message-clients/#exchange-and-routing","title":"Exchange and Routing","text":"<pre><code>class AmqpAgent &lt; Agent99::Base\n  def initialize\n    super(\n      message_client: 'amqp',\n      exchange: 'agent99.services',\n      routing_key: 'services.calculator'\n    )\n  end\n\n  def process_request(payload)\n    # AMQP-specific features\n    routing_key = current_routing_key\n    exchange = current_exchange\n\n    logger.info \"Message from: #{routing_key} on #{exchange}\"\n\n    # Can publish to specific routing keys\n    publish_to_routing_key('notifications.processed', {\n      agent: info[:name],\n      processed_at: Time.now.iso8601\n    })\n\n    send_response(\n      message: \"Processed via AMQP\",\n      routing_key: routing_key\n    )\n  end\nend\n</code></pre>"},{"location":"api-reference/message-clients/#tcp-client","title":"TCP Client","text":""},{"location":"api-reference/message-clients/#configuration_2","title":"Configuration","text":"<p>The TCP client is primarily for testing and simple setups:</p> <pre><code># Environment variables\nENV['TCP_HOST'] = 'localhost'\nENV['TCP_PORT'] = '9999'\n\n# Or programmatically\ntcp_config = {\n  host: 'localhost',\n  port: 9999,\n  timeout: 30\n}\n\nclient = Agent99::MessageClients::TcpClient.new(tcp_config)\n</code></pre>"},{"location":"api-reference/message-clients/#usage-example_1","title":"Usage Example","text":"<pre><code>class TcpAgent &lt; Agent99::Base\n  def initialize\n    super(message_client: 'tcp')\n  end\n\n  def process_request(payload)\n    client_address = current_client_address\n\n    logger.info \"Request from: #{client_address}\"\n\n    send_response(\n      message: \"Processed via TCP\",\n      client: client_address\n    )\n  end\nend\n</code></pre>"},{"location":"api-reference/message-clients/#message-client-api","title":"Message Client API","text":""},{"location":"api-reference/message-clients/#common-interface","title":"Common Interface","text":"<p>All message clients implement a common interface:</p> <pre><code>class MessageClientBase\n  def initialize(config = {})\n    # Initialize connection with config\n  end\n\n  def connect\n    # Establish connection to message broker\n  end\n\n  def disconnect\n    # Close connection\n  end\n\n  def subscribe(subject, &amp;block)\n    # Subscribe to messages on subject/queue\n  end\n\n  def publish(subject, message, options = {})\n    # Publish message to subject/exchange\n  end\n\n  def request(subject, message, options = {})\n    # Send request and wait for response\n  end\n\n  def connected?\n    # Check connection status\n  end\nend\n</code></pre>"},{"location":"api-reference/message-clients/#connection-management","title":"Connection Management","text":"<pre><code># Check connection status\nif client.connected?\n  logger.info \"Connected to message broker\"\nelse\n  logger.warn \"Not connected, attempting reconnect...\"\n  client.connect\nend\n\n# Graceful shutdown\nSignal.trap('TERM') do\n  logger.info \"Shutting down...\"\n  client.disconnect\n  exit\nend\n</code></pre>"},{"location":"api-reference/message-clients/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  response = client.request('service.calculate', payload, timeout: 10)\nrescue Agent99::MessageClient::TimeoutError\n  logger.error \"Request timed out\"\nrescue Agent99::MessageClient::ConnectionError =&gt; e\n  logger.error \"Connection failed: #{e.message}\"\n  # Attempt reconnection\n  client.connect\nrescue Agent99::MessageClient::Error =&gt; e\n  logger.error \"Message client error: #{e.message}\"\nend\n</code></pre>"},{"location":"api-reference/message-clients/#advanced-features","title":"Advanced Features","text":""},{"location":"api-reference/message-clients/#message-filtering","title":"Message Filtering","text":"<pre><code># NATS subject filtering\nclient.subscribe('services.calculator.*') do |message|\n  # Receives: services.calculator.add, services.calculator.multiply, etc.\nend\n\n# AMQP routing key patterns\nclient.subscribe('services.#') do |message|\n  # Receives all messages starting with 'services.'\nend\n</code></pre>"},{"location":"api-reference/message-clients/#message-persistence","title":"Message Persistence","text":"<pre><code># AMQP persistent messages\nclient.publish('important.task', payload, persistent: true)\n\n# NATS with JetStream persistence (if available)\nclient.publish('stream.data', payload, stream: 'EVENTS')\n</code></pre>"},{"location":"api-reference/message-clients/#load-balancing","title":"Load Balancing","text":"<pre><code># NATS queue groups for load balancing\nclient.subscribe('work.queue', queue: 'workers') do |message|\n  # Multiple subscribers share the work\nend\n\n# AMQP work queues\nclient.subscribe('task.queue', durable: true, ack: true) do |message|\n  process_task(message)\n  message.ack # Acknowledge completion\nend\n</code></pre>"},{"location":"api-reference/message-clients/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api-reference/message-clients/#connection-pooling","title":"Connection Pooling","text":"<pre><code>class PooledMessageClient\n  def initialize(config = {})\n    @pool_size = config[:pool_size] || 10\n    @pool = ConnectionPool.new(size: @pool_size) do\n      Agent99::MessageClients::NatsClient.new(config)\n    end\n  end\n\n  def with_connection(&amp;block)\n    @pool.with(&amp;block)\n  end\nend\n</code></pre>"},{"location":"api-reference/message-clients/#batching","title":"Batching","text":"<pre><code># Batch messages for better performance\nmessages = []\n(1..100).each do |i|\n  messages &lt;&lt; { id: i, data: \"message #{i}\" }\nend\n\n# Send in batches\nmessages.each_slice(10) do |batch|\n  batch.each { |msg| client.publish('batch.data', msg) }\n  sleep(0.1) # Rate limiting\nend\n</code></pre>"},{"location":"api-reference/message-clients/#monitoring","title":"Monitoring","text":"<pre><code>class MonitoredClient\n  def initialize(base_client)\n    @client = base_client\n    @metrics = {\n      messages_sent: 0,\n      messages_received: 0,\n      errors: 0\n    }\n  end\n\n  def publish(subject, message, options = {})\n    start_time = Time.now\n\n    begin\n      @client.publish(subject, message, options)\n      @metrics[:messages_sent] += 1\n    rescue =&gt; e\n      @metrics[:errors] += 1\n      raise\n    ensure\n      duration = Time.now - start_time\n      logger.debug \"Published to #{subject} in #{duration}s\"\n    end\n  end\n\n  def stats\n    @metrics.dup\n  end\nend\n</code></pre>"},{"location":"api-reference/message-clients/#testing-message-clients","title":"Testing Message Clients","text":""},{"location":"api-reference/message-clients/#mock-client-for-testing","title":"Mock Client for Testing","text":"<pre><code>class MockMessageClient\n  def initialize\n    @messages = []\n    @subscriptions = {}\n  end\n\n  def publish(subject, message, options = {})\n    @messages &lt;&lt; {\n      subject: subject,\n      message: message,\n      options: options,\n      timestamp: Time.now\n    }\n\n    # Trigger subscriptions\n    @subscriptions[subject]&amp;.each { |block| block.call(message) }\n  end\n\n  def subscribe(subject, &amp;block)\n    @subscriptions[subject] ||= []\n    @subscriptions[subject] &lt;&lt; block\n  end\n\n  def published_messages\n    @messages\n  end\n\n  def clear_messages\n    @messages.clear\n  end\nend\n</code></pre>"},{"location":"api-reference/message-clients/#integration-testing","title":"Integration Testing","text":"<pre><code>require 'minitest/autorun'\n\nclass TestMessageClientIntegration &lt; Minitest::Test\n  def setup\n    @client = Agent99::MessageClients::NatsClient.new\n    @client.connect\n  end\n\n  def teardown\n    @client.disconnect\n  end\n\n  def test_request_response\n    # Start a responder\n    response_thread = Thread.new do\n      @client.subscribe('test.echo') do |message|\n        @client.publish(message.reply, { echo: message.data })\n      end\n    end\n\n    # Send request\n    response = @client.request('test.echo', { text: 'hello' })\n\n    assert_equal 'hello', response[:echo][:text]\n\n    response_thread.kill\n  end\nend\n</code></pre>"},{"location":"api-reference/message-clients/#configuration-examples","title":"Configuration Examples","text":""},{"location":"api-reference/message-clients/#production-nats-cluster","title":"Production NATS Cluster","text":"<pre><code># config/nats.yml\nproduction:\n  servers:\n    - nats://nats1.example.com:4222\n    - nats://nats2.example.com:4222\n    - nats://nats3.example.com:4222\n  username: &lt;%= ENV['NATS_USERNAME'] %&gt;\n  password: &lt;%= ENV['NATS_PASSWORD'] %&gt;\n  tls:\n    cert_file: /etc/ssl/certs/client.crt\n    key_file: /etc/ssl/private/client.key\n    ca_file: /etc/ssl/certs/ca.crt\n</code></pre>"},{"location":"api-reference/message-clients/#production-rabbitmq","title":"Production RabbitMQ","text":"<pre><code># config/rabbitmq.yml\nproduction:\n  url: &lt;%= ENV['RABBITMQ_URL'] %&gt;\n  heartbeat: 30\n  connection_timeout: 10\n  read_timeout: 30\n  write_timeout: 30\n  ssl:\n    enabled: true\n    verify: true\n    cert_path: /etc/ssl/certs/client.pem\n    key_path: /etc/ssl/private/client.key\n</code></pre>"},{"location":"api-reference/message-clients/#next-steps","title":"Next Steps","text":"<ul> <li>Agent99::Base - Core agent class reference</li> <li>Registry Client - Registry service API</li> <li>Configuration - Detailed configuration options</li> </ul>"},{"location":"api-reference/overview/","title":"Agent99 Framework API Reference","text":""},{"location":"api-reference/overview/#agent-implementation-requirements","title":"Agent Implementation Requirements","text":"<p>When creating a new agent by subclassing <code>Agent99::Base</code>, you must implement certain methods and may optionally override others.</p>"},{"location":"api-reference/overview/#required-methods","title":"Required Methods","text":""},{"location":"api-reference/overview/#info","title":"<code>info</code>","text":"<p>The <code>info</code> method provides a comprehensive information packet about the agent. It returns a hash containing key details that are crucial for agent registration and discovery within the system. <pre><code>def info\n  {\n    name:             self.class.to_s,\n    type:             :server,\n    capabilities:     %w[ greeter hello_world hello-world hello],\n    request_schema:   MaxwellRequest.schema,\n    # response_schema:  {}, # Agent99::RESPONSE.schema\n    # control_schema:   {}, # Agent99::CONTROL.schema\n    # error_schema:     {}, # Agent99::ERROR.schema\n  }\nend\n</code></pre></p> <p>Entries for :name and :capabilities are required.  Other entries are optional.  This entire info packet is stored by the central registry and provided to other agents on a discover \"hit\" so that the inquiring agents know all the target agent is willing to tell them.</p>"},{"location":"api-reference/overview/#receive_request","title":"<code>receive_request</code>","text":"<p>Handles incoming request messages. Must be implemented if the agent accepts requests. <pre><code>def receive_request\n  # Process the request message in @payload\n  # Access message data via @payload[:data]\n  # Send response using send_response(response_data)\nend\n</code></pre></p>"},{"location":"api-reference/overview/#optional-methods","title":"Optional Methods","text":""},{"location":"api-reference/overview/#init","title":"<code>init</code>","text":"<p>Called after registration but before message processing begins. Use for additional setup. <pre><code>def init\n  @state = initialize_state\n  @resources = setup_resources\nend\n</code></pre></p>"},{"location":"api-reference/overview/#fini","title":"<code>fini</code>","text":"<p>Called during shutdown. Override to add custom cleanup. <pre><code>def fini\n  cleanup_resources\n  save_state if @state\n  super  # Always call super last\nend\n</code></pre></p>"},{"location":"api-reference/overview/#receive_response","title":"<code>receive_response</code>","text":"<p>Handles incoming response messages. Override if the agent processes responses. <pre><code>def receive_response\n  # Process the response message in @payload\nend\n</code></pre></p>"},{"location":"api-reference/overview/#message-client-interface","title":"Message Client Interface","text":"<p>To implement a custom message client, create a class that implements these methods:</p>"},{"location":"api-reference/overview/#required-methods_1","title":"Required Methods","text":""},{"location":"api-reference/overview/#initializelogger-loggernewstdout","title":"<code>initialize(logger: Logger.new($stdout))</code>","text":"<p>Sets up the messaging connection.</p>"},{"location":"api-reference/overview/#setupagent_id-logger","title":"<code>setup(agent_id:, logger:)</code>","text":"<p>Initializes message queues/topics for the agent. - Returns: queue/topic identifier</p>"},{"location":"api-reference/overview/#listen_for_messagesqueue-request_handler-response_handler-control_handler","title":"<code>listen_for_messages(queue, request_handler:, response_handler:, control_handler:)</code>","text":"<p>Starts listening for messages. - <code>queue</code>: Queue/topic to listen on - <code>request_handler</code>: Lambda for handling requests - <code>response_handler</code>: Lambda for handling responses - <code>control_handler</code>: Lambda for handling control messages</p>"},{"location":"api-reference/overview/#publishmessage","title":"<code>publish(message)</code>","text":"<p>Publishes a message. - <code>message</code>: Hash containing the message with :header and payload - Returns: Hash with :success and optional :error</p>"},{"location":"api-reference/overview/#delete_queuequeue_name","title":"<code>delete_queue(queue_name)</code>","text":"<p>Cleans up agent's message queue/topic.</p>"},{"location":"api-reference/overview/#registry-client-interface","title":"Registry Client Interface","text":"<p>To implement a custom registry client, create a class that implements these methods:</p>"},{"location":"api-reference/overview/#required-methods_2","title":"Required Methods","text":""},{"location":"api-reference/overview/#initializebase_url-envfetchregistry_base_url-httplocalhost4567-logger-loggernewstdout","title":"<code>initialize(base_url: ENV.fetch('REGISTRY_BASE_URL', 'http://localhost:4567'), logger: Logger.new($stdout))</code>","text":"<p>Sets up the registry connection.</p>"},{"location":"api-reference/overview/#registername-capabilities","title":"<code>register(name:, capabilities:)</code>","text":"<p>Registers an agent with the registry. - Returns: UUID string for the agent</p>"},{"location":"api-reference/overview/#withdrawid","title":"<code>withdraw(id)</code>","text":"<p>Removes an agent from the registry.</p>"},{"location":"api-reference/overview/#base-class-public-methods","title":"Base Class Public Methods","text":"<p>The <code>Agent99::Base</code> class provides these public methods:</p>"},{"location":"api-reference/overview/#run","title":"<code>run</code>","text":"<p>Starts the agent's message processing loop.</p>"},{"location":"api-reference/overview/#discover_agentcapability-how_many-1-all-false","title":"<code>discover_agent(capability:, how_many: 1, all: false)</code>","text":"<p>Finds other agents by capability. - Returns: Array of agent information hashes</p>"},{"location":"api-reference/overview/#send_responseresponse","title":"<code>send_response(response)</code>","text":"<p>Sends a response message. - <code>response</code>: Hash containing the response data</p>"},{"location":"api-reference/overview/#message-types","title":"Message Types","text":"<p>Messages in Agent99 must include a <code>:header</code> with: - <code>:type</code>: One of \"request\", \"response\", or \"control\" - <code>:to_uuid</code>: Destination agent's UUID - <code>:from_uuid</code>: Sending agent's UUID - <code>:event_uuid</code>: UUID to link request to response - <code>:timestamp</code>: Integer (<code>Agent99::Timestamp.new.to_i</code>)</p> <p>Example request message structure: <pre><code>{\n  header: {\n    type:       'request',\n    to_uuid:    ,\n    from_uuid:  ,\n    event_uuid: ,\n    timestamp:  ,\n  },\n  # agent specific parameters\n}\n</code></pre></p>"},{"location":"api-reference/registry-client/","title":"Registry Client API","text":"<p>The Registry Client provides programmatic access to the Agent99 registry service for agent registration, discovery, and management operations.</p>"},{"location":"api-reference/registry-client/#overview","title":"Overview","text":"<p>The registry client is built into <code>Agent99::Base</code> but can also be used independently for advanced registry operations.</p>"},{"location":"api-reference/registry-client/#basic-usage","title":"Basic Usage","text":""},{"location":"api-reference/registry-client/#auto-registration-built-in","title":"Auto-Registration (Built-in)","text":"<p>Most agents use automatic registration through the base class:</p> <pre><code>class MyAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['example', 'demo']\n    }\n  end\n\n  def process_request(payload)\n    # Agent automatically registers on startup\n    send_response(message: \"Hello from registered agent!\")\n  end\nend\n</code></pre>"},{"location":"api-reference/registry-client/#manual-registration","title":"Manual Registration","text":"<p>For advanced use cases, you can manually register agents:</p> <pre><code>registry = Agent99::RegistryClient.new\nagent_info = {\n  name: \"CustomAgent\",\n  type: \"server\",\n  capabilities: [\"custom\", \"manual\"],\n  host: \"localhost\",\n  port: 5000\n}\n\n# Register the agent\nregistry.register_agent(agent_info)\n</code></pre>"},{"location":"api-reference/registry-client/#registry-client-methods","title":"Registry Client Methods","text":""},{"location":"api-reference/registry-client/#register_agentagent_info","title":"<code>#register_agent(agent_info)</code>","text":"<p>Registers an agent with the registry.</p> <pre><code>def register_agent(agent_info)\n  # POST /agents\nend\n</code></pre> <p>Parameters: - <code>agent_info</code> (Hash) - Agent information</p> <p>Required Fields: - <code>name</code> (String) - Unique agent name - <code>type</code> (String) - Agent type (<code>\"server\"</code>, <code>\"client\"</code>, <code>\"hybrid\"</code>) - <code>capabilities</code> (Array) - List of capabilities</p> <p>Optional Fields: - <code>host</code> (String) - Agent host (default: detected) - <code>port</code> (Integer) - Agent port (default: auto-assigned) - <code>metadata</code> (Hash) - Additional metadata - <code>schema</code> (Hash) - Request/response schemas</p> <p>Example: <pre><code>registry.register_agent({\n  name: \"WeatherService\",\n  type: \"server\", \n  capabilities: [\"weather\", \"forecast\", \"temperature\"],\n  host: \"weather.example.com\",\n  port: 8080,\n  metadata: {\n    version: \"1.2.3\",\n    region: \"us-west\"\n  }\n})\n</code></pre></p>"},{"location":"api-reference/registry-client/#unregister_agentagent_name","title":"<code>#unregister_agent(agent_name)</code>","text":"<p>Removes an agent from the registry.</p> <pre><code>def unregister_agent(agent_name)\n  # DELETE /agents/:name\nend\n</code></pre> <p>Parameters: - <code>agent_name</code> (String) - Name of agent to remove</p> <p>Example: <pre><code>registry.unregister_agent(\"WeatherService\")\n</code></pre></p>"},{"location":"api-reference/registry-client/#discover_agentscapabilities","title":"<code>#discover_agents(capabilities = [])</code>","text":"<p>Finds agents that match specified capabilities.</p> <pre><code>def discover_agents(capabilities = [])\n  # GET /agents/discover?capabilities=cap1,cap2\nend\n</code></pre> <p>Parameters: - <code>capabilities</code> (Array) - Required capabilities (empty array returns all)</p> <p>Returns: Array of agent information hashes</p> <p>Example: <pre><code># Find all weather agents\nweather_agents = registry.discover_agents([\"weather\"])\n\n# Find agents with multiple capabilities  \ncalc_agents = registry.discover_agents([\"calculator\", \"math\"])\n\n# Find all agents\nall_agents = registry.discover_agents([])\n</code></pre></p>"},{"location":"api-reference/registry-client/#get_agentagent_name","title":"<code>#get_agent(agent_name)</code>","text":"<p>Retrieves detailed information about a specific agent.</p> <pre><code>def get_agent(agent_name)\n  # GET /agents/:name\nend\n</code></pre> <p>Parameters: - <code>agent_name</code> (String) - Agent name</p> <p>Returns: Agent information hash or nil if not found</p> <p>Example: <pre><code>agent_info = registry.get_agent(\"WeatherService\")\nif agent_info\n  puts \"Agent capabilities: #{agent_info[:capabilities]}\"\nelse\n  puts \"Agent not found\"\nend\n</code></pre></p>"},{"location":"api-reference/registry-client/#list_agents","title":"<code>#list_agents</code>","text":"<p>Lists all registered agents.</p> <pre><code>def list_agents\n  # GET /agents\nend\n</code></pre> <p>Returns: Array of all registered agent information</p> <p>Example: <pre><code>all_agents = registry.list_agents\nputs \"Total agents: #{all_agents.size}\"\n\nall_agents.each do |agent|\n  puts \"#{agent[:name]} (#{agent[:type]}) - #{agent[:capabilities].join(', ')}\"\nend\n</code></pre></p>"},{"location":"api-reference/registry-client/#health_check","title":"<code>#health_check</code>","text":"<p>Checks registry service health.</p> <pre><code>def health_check\n  # GET /health\nend\n</code></pre> <p>Returns: Health status hash</p> <p>Example: <pre><code>health = registry.health_check\nputs \"Registry status: #{health[:status]}\"\nputs \"Uptime: #{health[:uptime]}\"\n</code></pre></p>"},{"location":"api-reference/registry-client/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api-reference/registry-client/#custom-registry-client","title":"Custom Registry Client","text":"<p>For applications that need to interact with multiple registries or require custom configuration:</p> <pre><code>require 'agent99/registry_client'\n\n# Custom registry client\nregistry = Agent99::RegistryClient.new(\n  base_url: 'http://registry.example.com:8080',\n  timeout: 15,\n  retry_attempts: 5\n)\n\n# Use custom client\nagents = registry.discover_agents(['database'])\n</code></pre>"},{"location":"api-reference/registry-client/#registry-client-configuration","title":"Registry Client Configuration","text":"<pre><code>class Agent99::RegistryClient\n  def initialize(options = {})\n    @base_url = options[:base_url] || ENV['AGENT99_REGISTRY_URL'] || 'http://localhost:4567'\n    @timeout = options[:timeout] || 30\n    @retry_attempts = options[:retry_attempts] || 3\n    @retry_delay = options[:retry_delay] || 1\n  end\nend\n</code></pre> <p>Configuration Options: - <code>base_url</code> - Registry service URL - <code>timeout</code> - HTTP timeout in seconds - <code>retry_attempts</code> - Number of retry attempts - <code>retry_delay</code> - Delay between retries in seconds</p>"},{"location":"api-reference/registry-client/#error-handling","title":"Error Handling","text":"<p>The registry client raises specific exceptions for different error conditions:</p> <pre><code>begin\n  registry.register_agent(agent_info)\nrescue Agent99::RegistryError =&gt; e\n  case e.code\n  when 'AGENT_EXISTS'\n    puts \"Agent already registered\"\n  when 'VALIDATION_ERROR'\n    puts \"Invalid agent info: #{e.message}\"\n  when 'REGISTRY_UNAVAILABLE'\n    puts \"Registry service unavailable\"\n  else\n    puts \"Registration failed: #{e.message}\"\n  end\nend\n</code></pre>"},{"location":"api-reference/registry-client/#common-exceptions","title":"Common Exceptions","text":"<ul> <li><code>Agent99::RegistryError</code> - Base registry exception</li> <li><code>Agent99::RegistryConnectionError</code> - Network/connection issues  </li> <li><code>Agent99::RegistryValidationError</code> - Invalid agent data</li> <li><code>Agent99::RegistryNotFoundError</code> - Agent/resource not found</li> </ul>"},{"location":"api-reference/registry-client/#response-formats","title":"Response Formats","text":""},{"location":"api-reference/registry-client/#agent-information-structure","title":"Agent Information Structure","text":"<pre><code>{\n  \"name\": \"WeatherService\",\n  \"type\": \"server\",\n  \"capabilities\": [\"weather\", \"forecast\"],\n  \"host\": \"localhost\", \n  \"port\": 8080,\n  \"registered_at\": \"2024-12-12T10:30:00Z\",\n  \"last_seen\": \"2024-12-12T10:35:00Z\",\n  \"metadata\": {\n    \"version\": \"1.2.3\",\n    \"region\": \"us-west\"\n  },\n  \"schema\": {\n    \"request\": { /* JSON Schema */ },\n    \"response\": { /* JSON Schema */ }\n  }\n}\n</code></pre>"},{"location":"api-reference/registry-client/#discovery-response","title":"Discovery Response","text":"<pre><code>{\n  \"agents\": [\n    {\n      \"name\": \"WeatherService\",\n      \"type\": \"server\", \n      \"capabilities\": [\"weather\", \"forecast\"],\n      \"host\": \"localhost\",\n      \"port\": 8080\n    }\n  ],\n  \"total_count\": 1,\n  \"matching_capabilities\": [\"weather\"]\n}\n</code></pre>"},{"location":"api-reference/registry-client/#registry-http-api","title":"Registry HTTP API","text":"<p>The registry exposes a REST API that the client uses:</p>"},{"location":"api-reference/registry-client/#endpoints","title":"Endpoints","text":"Method Endpoint Description <code>POST</code> <code>/agents</code> Register new agent <code>GET</code> <code>/agents</code> List all agents <code>GET</code> <code>/agents/:name</code> Get specific agent <code>DELETE</code> <code>/agents/:name</code> Unregister agent <code>GET</code> <code>/agents/discover</code> Discover agents by capabilities <code>GET</code> <code>/health</code> Registry health check"},{"location":"api-reference/registry-client/#query-parameters","title":"Query Parameters","text":"<p>Discovery endpoint (<code>/agents/discover</code>): - <code>capabilities</code> - Comma-separated list of required capabilities - <code>type</code> - Filter by agent type (<code>server</code>, <code>client</code>, <code>hybrid</code>) - <code>limit</code> - Maximum number of results - <code>offset</code> - Pagination offset</p> <p>Example requests: <pre><code># Find weather agents\nGET /agents/discover?capabilities=weather\n\n# Find server agents with math capability\nGET /agents/discover?capabilities=math&amp;type=server\n\n# Paginated results\nGET /agents/discover?limit=10&amp;offset=20\n</code></pre></p>"},{"location":"api-reference/registry-client/#testing-registry-operations","title":"Testing Registry Operations","text":""},{"location":"api-reference/registry-client/#unit-tests","title":"Unit Tests","text":"<pre><code>require 'minitest/autorun'\nrequire 'webmock/minitest'\n\nclass TestRegistryClient &lt; Minitest::Test\n  def setup\n    @registry = Agent99::RegistryClient.new(\n      base_url: 'http://test-registry:4567'\n    )\n  end\n\n  def test_agent_registration\n    agent_info = {\n      name: \"TestAgent\",\n      type: \"server\",\n      capabilities: [\"test\"]\n    }\n\n    # Mock the HTTP request\n    stub_request(:post, \"http://test-registry:4567/agents\")\n      .with(body: agent_info.to_json)\n      .to_return(status: 201, body: '{\"status\": \"registered\"}')\n\n    result = @registry.register_agent(agent_info)\n    assert_equal \"registered\", result[\"status\"]\n  end\n\n  def test_agent_discovery\n    # Mock discovery response\n    response_body = {\n      agents: [\n        { name: \"TestAgent\", capabilities: [\"test\"] }\n      ]\n    }.to_json\n\n    stub_request(:get, \"http://test-registry:4567/agents/discover\")\n      .with(query: { capabilities: \"test\" })\n      .to_return(status: 200, body: response_body)\n\n    agents = @registry.discover_agents([\"test\"])\n    assert_equal 1, agents.size\n    assert_equal \"TestAgent\", agents.first[\"name\"]\n  end\nend\n</code></pre>"},{"location":"api-reference/registry-client/#integration-tests","title":"Integration Tests","text":"<pre><code>class TestRegistryIntegration &lt; Minitest::Test\n  def setup\n    # Start test registry server\n    @registry_server = start_test_registry\n    @registry = Agent99::RegistryClient.new(\n      base_url: 'http://localhost:4567'\n    )\n  end\n\n  def teardown\n    @registry_server.stop\n  end\n\n  def test_full_agent_lifecycle\n    agent_info = {\n      name: \"IntegrationTestAgent\", \n      type: \"server\",\n      capabilities: [\"integration\", \"test\"]\n    }\n\n    # Register agent\n    @registry.register_agent(agent_info)\n\n    # Verify registration\n    found_agents = @registry.discover_agents([\"integration\"])\n    assert_equal 1, found_agents.size\n\n    # Get agent details\n    agent_details = @registry.get_agent(\"IntegrationTestAgent\")\n    assert_equal \"server\", agent_details[\"type\"]\n\n    # Unregister agent\n    @registry.unregister_agent(\"IntegrationTestAgent\")\n\n    # Verify removal\n    found_agents = @registry.discover_agents([\"integration\"])\n    assert_empty found_agents\n  end\nend\n</code></pre>"},{"location":"api-reference/registry-client/#best-practices","title":"Best Practices","text":""},{"location":"api-reference/registry-client/#1-registration","title":"1. Registration","text":"<ul> <li>Use descriptive names: Include service purpose and instance info</li> <li>Provide rich metadata: Version, region, capabilities</li> <li>Handle registration failures: Retry with backoff</li> <li>Clean up on shutdown: Always unregister agents</li> </ul>"},{"location":"api-reference/registry-client/#2-discovery","title":"2. Discovery","text":"<ul> <li>Cache results: Don't discover on every request</li> <li>Handle empty results: Plan for no matching agents</li> <li>Use specific capabilities: More specific = better matches</li> <li>Implement fallbacks: Have backup discovery strategies</li> </ul>"},{"location":"api-reference/registry-client/#3-error-handling","title":"3. Error Handling","text":"<ul> <li>Catch specific exceptions: Handle different error types appropriately</li> <li>Implement retries: With exponential backoff</li> <li>Monitor registry health: Check before critical operations</li> <li>Log registry operations: For debugging and monitoring</li> </ul>"},{"location":"api-reference/registry-client/#4-performance","title":"4. Performance","text":"<ul> <li>Batch operations: When possible, batch registry calls</li> <li>Use connection pooling: For high-frequency operations</li> <li>Monitor response times: Track registry performance</li> <li>Implement circuit breakers: Protect against registry failures</li> </ul>"},{"location":"api-reference/registry-client/#next-steps","title":"Next Steps","text":"<ul> <li>Message Clients - Message broker client APIs</li> <li>Agent99::Base - Core agent class reference  </li> <li>Configuration - Registry configuration options</li> </ul>"},{"location":"api-reference/schemas/","title":"Schemas API","text":"<p>Agent99 uses JSON Schema validation to ensure data integrity in agent communication. This document covers the schema system, built-in schemas, and how to create custom validation schemas.</p>"},{"location":"api-reference/schemas/#overview","title":"Overview","text":"<p>Agent99 leverages <code>simple_json_schema_builder</code> to define and validate request/response schemas, providing:</p> <ul> <li>Type safety - Ensure data types match expectations</li> <li>Required field validation - Enforce mandatory fields</li> <li>Format validation - Validate emails, URLs, dates, etc.</li> <li>Custom validation - Define business-specific rules</li> <li>Auto-documentation - Schemas serve as API documentation</li> </ul>"},{"location":"api-reference/schemas/#built-in-schemas","title":"Built-in Schemas","text":""},{"location":"api-reference/schemas/#header-schema","title":"Header Schema","text":"<p>All Agent99 messages include a standard header:</p> <pre><code>class Agent99::HeaderSchema &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    string :request_id, required: true, format: :uuid\n    string :agent_name, required: true\n    string :correlation_id, format: :uuid\n    string :timestamp, required: true, format: :datetime\n    string :reply_to\n    object :metadata do\n      # Additional metadata fields\n    end\n  end\nend\n</code></pre> <p>Example usage: <pre><code>header = {\n  request_id: SecureRandom.uuid,\n  agent_name: \"CalculatorAgent\",\n  correlation_id: SecureRandom.uuid,\n  timestamp: Time.now.iso8601,\n  metadata: { version: \"1.0.0\" }\n}\n\n# Validate header\nAgent99::HeaderSchema.new.validate!(header)\n</code></pre></p>"},{"location":"api-reference/schemas/#basic-message-schema","title":"Basic Message Schema","text":"<p>Base schema for all agent messages:</p> <pre><code>class Agent99::MessageSchema &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema, required: true\n    # Payload varies by message type\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#creating-custom-schemas","title":"Creating Custom Schemas","text":""},{"location":"api-reference/schemas/#simple-request-schema","title":"Simple Request Schema","text":"<pre><code>require 'simple_json_schema_builder'\n\nclass GreetingRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n    string :name, required: true, minLength: 1, maxLength: 100\n    string :language, enum: %w[en es fr de], default: 'en'\n    boolean :formal, default: false\n  end\nend\n\n# Usage in agent\nclass GreeterAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['greeting'],\n      request_schema: GreetingRequest.schema\n    }\n  end\n\n  def process_request(payload)\n    # Payload is automatically validated against schema\n    name = payload[:name]\n    language = payload[:language] || 'en'\n    formal = payload[:formal] || false\n\n    greeting = generate_greeting(name, language, formal)\n    send_response(message: greeting)\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#complex-schema-with-nested-objects","title":"Complex Schema with Nested Objects","text":"<pre><code>class OrderRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n\n    string :customer_id, required: true, format: :uuid\n\n    array :items, required: true, minItems: 1 do\n      object do\n        string :product_id, required: true, format: :uuid\n        integer :quantity, required: true, minimum: 1\n        number :unit_price, required: true, minimum: 0\n        object :metadata do\n          string :color\n          string :size, enum: %w[XS S M L XL XXL]\n          boolean :gift_wrap, default: false\n        end\n      end\n    end\n\n    object :shipping_address, required: true do\n      string :street, required: true\n      string :city, required: true\n      string :state, required: true\n      string :zip_code, required: true, pattern: '^\\d{5}(-\\d{4})?$'\n      string :country, required: true, enum: %w[US CA MX]\n    end\n\n    object :payment do\n      string :method, required: true, enum: %w[credit_card paypal bank_transfer]\n      string :token, required: true\n      number :amount, required: true, minimum: 0\n    end\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#response-schema","title":"Response Schema","text":"<pre><code>class OrderResponse &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n\n    string :order_id, required: true, format: :uuid\n    string :status, required: true, enum: %w[pending confirmed processing shipped delivered cancelled]\n    number :total_amount, required: true, minimum: 0\n    string :estimated_delivery, format: :datetime\n\n    array :items do\n      object do\n        string :product_id, required: true\n        integer :quantity, required: true\n        number :line_total, required: true\n        string :status, enum: %w[available backordered discontinued]\n      end\n    end\n\n    object :tracking do\n      string :carrier\n      string :tracking_number\n      string :tracking_url, format: :uri\n    end\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#schema-validation","title":"Schema Validation","text":""},{"location":"api-reference/schemas/#automatic-validation","title":"Automatic Validation","text":"<p>Agent99 automatically validates incoming requests against defined schemas:</p> <pre><code>class ValidatingAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['validation_example'],\n      request_schema: OrderRequest.schema,\n      response_schema: OrderResponse.schema\n    }\n  end\n\n  def process_request(payload)\n    # payload is already validated by framework\n\n    order_id = SecureRandom.uuid\n    total = calculate_total(payload[:items])\n\n    response = {\n      order_id: order_id,\n      status: 'confirmed',\n      total_amount: total,\n      estimated_delivery: (Time.now + 7.days).iso8601,\n      items: process_items(payload[:items])\n    }\n\n    # Response will be validated before sending\n    send_response(response)\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#manual-validation","title":"Manual Validation","text":"<p>For custom validation scenarios:</p> <pre><code>def process_request(payload)\n  # Additional business logic validation\n  begin\n    validate_business_rules(payload)\n  rescue ValidationError =&gt; e\n    return send_error(\"Business validation failed: #{e.message}\", \"BUSINESS_VALIDATION_ERROR\")\n  end\n\n  # Continue processing...\nend\n\nprivate\n\ndef validate_business_rules(payload)\n  customer_id = payload[:customer_id]\n\n  # Check customer exists and is active\n  customer = Customer.find(customer_id)\n  raise ValidationError, \"Customer not found\" unless customer\n  raise ValidationError, \"Customer account suspended\" unless customer.active?\n\n  # Validate inventory\n  payload[:items].each do |item|\n    product = Product.find(item[:product_id])\n    raise ValidationError, \"Product #{item[:product_id]} not available\" unless product&amp;.available?\n    raise ValidationError, \"Insufficient inventory for #{product.name}\" if product.stock &lt; item[:quantity]\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#advanced-schema-features","title":"Advanced Schema Features","text":""},{"location":"api-reference/schemas/#conditional-schemas","title":"Conditional Schemas","text":"<pre><code>class ConditionalRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n    string :operation, required: true, enum: %w[create update delete]\n\n    # Conditional fields based on operation\n    if_property :operation, equals: 'create' do\n      string :name, required: true\n      string :email, required: true, format: :email\n    end\n\n    if_property :operation, equals: 'update' do\n      string :id, required: true, format: :uuid\n      string :name\n      string :email, format: :email\n    end\n\n    if_property :operation, equals: 'delete' do\n      string :id, required: true, format: :uuid\n    end\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#custom-format-validators","title":"Custom Format Validators","text":"<pre><code># Define custom formats\nSimpleJsonSchemaBuilder.configure do |config|\n  config.add_format :phone_number, /^\\+?[\\d\\s\\-\\(\\)]+$/\n  config.add_format :product_sku, /^[A-Z]{2}\\d{6}$/\nend\n\nclass ProductRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n    string :sku, required: true, format: :product_sku\n    string :support_phone, format: :phone_number\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#schema-composition","title":"Schema Composition","text":"<pre><code># Base schemas for reuse\nclass AddressSchema &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    string :street, required: true\n    string :city, required: true\n    string :state, required: true\n    string :zip_code, required: true\n    string :country, required: true\n  end\nend\n\nclass PersonSchema &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    string :first_name, required: true\n    string :last_name, required: true\n    string :email, format: :email\n    string :phone, format: :phone_number\n  end\nend\n\n# Compose into larger schema\nclass CustomerRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n    object :personal_info, schema: PersonSchema, required: true\n    object :billing_address, schema: AddressSchema, required: true\n    object :shipping_address, schema: AddressSchema\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#schema-testing","title":"Schema Testing","text":""},{"location":"api-reference/schemas/#unit-tests","title":"Unit Tests","text":"<pre><code>require 'minitest/autorun'\n\nclass TestOrderSchema &lt; Minitest::Test\n  def test_valid_order_request\n    valid_payload = {\n      header: {\n        request_id: SecureRandom.uuid,\n        agent_name: \"TestAgent\",\n        timestamp: Time.now.iso8601\n      },\n      customer_id: SecureRandom.uuid,\n      items: [\n        {\n          product_id: SecureRandom.uuid,\n          quantity: 2,\n          unit_price: 29.99\n        }\n      ],\n      shipping_address: {\n        street: \"123 Main St\",\n        city: \"Anytown\",\n        state: \"CA\",\n        zip_code: \"12345\",\n        country: \"US\"\n      }\n    }\n\n    schema = OrderRequest.new\n    assert schema.valid?(valid_payload)\n  end\n\n  def test_invalid_order_request\n    invalid_payload = {\n      header: {\n        request_id: \"not-a-uuid\",  # Invalid format\n        agent_name: \"TestAgent\",\n        timestamp: Time.now.iso8601\n      },\n      items: [],  # Empty array not allowed\n      shipping_address: {\n        # Missing required fields\n        street: \"123 Main St\"\n      }\n    }\n\n    schema = OrderRequest.new\n    refute schema.valid?(invalid_payload)\n\n    errors = schema.validate(invalid_payload)\n    assert errors.any? { |e| e.include?(\"request_id\") }\n    assert errors.any? { |e| e.include?(\"items\") }\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#schema-documentation-generation","title":"Schema Documentation Generation","text":"<pre><code>class SchemaDocGenerator\n  def self.generate_docs(schema_class, output_file)\n    schema = schema_class.schema\n\n    docs = {\n      title: schema_class.name,\n      description: extract_description(schema),\n      properties: extract_properties(schema),\n      required: schema.dig('required') || [],\n      examples: generate_examples(schema)\n    }\n\n    File.write(output_file, docs.to_json)\n  end\n\n  private\n\n  def self.extract_properties(schema)\n    schema.dig('properties') || {}\n  end\n\n  def self.generate_examples(schema)\n    # Generate example data based on schema\n    example_generator = JsonSchemaExampleGenerator.new(schema)\n    example_generator.generate\n  end\nend\n\n# Generate documentation\nSchemaDocGenerator.generate_docs(OrderRequest, 'docs/schemas/order_request.json')\n</code></pre>"},{"location":"api-reference/schemas/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/schemas/#schema-validation-errors","title":"Schema Validation Errors","text":"<pre><code>class OrderAgent &lt; Agent99::Base\n  def process_request(payload)\n    # Framework automatically validates, but you can catch validation errors\n    begin\n      validate_additional_rules(payload)\n    rescue Agent99::SchemaValidationError =&gt; e\n      return send_error(\n        \"Validation failed: #{e.message}\",\n        \"SCHEMA_VALIDATION_ERROR\",\n        {\n          errors: e.validation_errors,\n          schema_version: \"1.0.0\"\n        }\n      )\n    end\n\n    # Process valid request...\n  end\n\n  private\n\n  def validate_additional_rules(payload)\n    # Custom validation beyond schema\n    if payload[:items].sum { |item| item[:quantity] } &gt; 100\n      raise Agent99::SchemaValidationError, \"Order too large (max 100 items)\"\n    end\n  end\nend\n</code></pre>"},{"location":"api-reference/schemas/#schema-version-management","title":"Schema Version Management","text":"<pre><code>class VersionedSchema\n  SCHEMA_VERSIONS = {\n    \"1.0\" =&gt; OrderRequestV1,\n    \"1.1\" =&gt; OrderRequestV11,\n    \"2.0\" =&gt; OrderRequestV2\n  }.freeze\n\n  def self.validate(payload, version = \"2.0\")\n    schema_class = SCHEMA_VERSIONS[version]\n    raise ArgumentError, \"Unsupported schema version: #{version}\" unless schema_class\n\n    schema = schema_class.new\n    unless schema.valid?(payload)\n      errors = schema.validate(payload)\n      raise Agent99::SchemaValidationError, \"Validation failed: #{errors.join(', ')}\"\n    end\n\n    payload\n  end\nend\n\n# Usage in agent\ndef process_request(payload)\n  schema_version = header_value('schema_version') || \"2.0\"\n  validated_payload = VersionedSchema.validate(payload, schema_version)\n\n  # Process with validated payload...\nend\n</code></pre>"},{"location":"api-reference/schemas/#best-practices","title":"Best Practices","text":""},{"location":"api-reference/schemas/#1-schema-design","title":"1. Schema Design","text":"<ul> <li>Be explicit: Define all expected fields and types</li> <li>Use descriptive names: Clear field names and descriptions</li> <li>Version your schemas: Plan for schema evolution</li> <li>Provide examples: Include example payloads in documentation</li> </ul>"},{"location":"api-reference/schemas/#2-validation-strategy","title":"2. Validation Strategy","text":"<ul> <li>Validate early: Catch errors as soon as possible</li> <li>Provide clear errors: Include helpful validation messages</li> <li>Use business validation: Complement schema validation with business rules</li> <li>Test thoroughly: Cover valid and invalid cases</li> </ul>"},{"location":"api-reference/schemas/#3-performance","title":"3. Performance","text":"<ul> <li>Cache compiled schemas: Don't recompile schemas on every request</li> <li>Validate incrementally: Only validate changed portions when possible</li> <li>Monitor validation time: Track validation performance</li> <li>Use appropriate depth: Don't over-validate in performance-critical paths</li> </ul>"},{"location":"api-reference/schemas/#4-evolution","title":"4. Evolution","text":"<ul> <li>Backward compatibility: Plan for schema changes</li> <li>Optional fields: Use optional fields for new features</li> <li>Deprecation strategy: Plan how to retire old schema versions</li> <li>Migration support: Provide tools to migrate between schema versions</li> </ul>"},{"location":"api-reference/schemas/#next-steps","title":"Next Steps","text":"<ul> <li>Agent99::Base - Core agent class reference</li> <li>Message Clients - Message broker APIs</li> <li>Schema Definition - Detailed schema guide</li> </ul>"},{"location":"core-concepts/agent-lifecycle/","title":"Agent99 Framework","text":""},{"location":"core-concepts/agent-lifecycle/#agent-lifecycle","title":"Agent Lifecycle","text":"<p>The lifecycle of an agent within Agent99 consists of several key stages that are managed through dedicated lifecycle methods. Understanding these stages and their corresponding methods is crucial for proper agent implementation.</p>"},{"location":"core-concepts/agent-lifecycle/#lifecycle-stages","title":"Lifecycle Stages","text":"<ol> <li>Creation: An agent is instantiated through the <code>Agent99::Base</code> class.</li> <li>Initialization: The agent sets up resources and establishes connections.</li> <li>Running: The agent processes messages and performs its designated tasks.</li> <li>Shutdown: The agent performs cleanup and gracefully terminates.</li> </ol>"},{"location":"core-concepts/agent-lifecycle/#core-lifecycle-methods","title":"Core Lifecycle Methods","text":""},{"location":"core-concepts/agent-lifecycle/#the-init-method","title":"The <code>init</code> Method","text":"<p>The <code>init</code> method is called automatically after the agent has been registered but before it starts processing messages. Its primary purpose is to perform any additional setup required for the agent following the default initialization provided by the <code>Agent99::Base</code> class. This may include:</p> <ul> <li>Setting up initial state</li> <li>Establishing connections to other agents or resources</li> <li>Discovering dependencies or agents to communicate with</li> <li>Sending initial messages to specific agents</li> </ul> <p>Here\u2019s an example implementation:</p> <pre><code>def init  \n  @state      = initialize_state\n  @resources  = setup_resources\nend\n</code></pre>"},{"location":"core-concepts/agent-lifecycle/#custom-initialization","title":"Custom Initialization","text":"<p>Agents can choose to either use the default behavior provided by the <code>Agent99::Base</code> class or implement their own <code>initialize</code> method to customize the <code>logger</code>, <code>message_client</code>, and <code>registry_client</code> attributes. For instance:</p> <ol> <li>Using Defaults: If you do not define an <code>initialize</code> method in your agent class, it will inherit the defaults:</li> </ol> <pre><code>class MyAgent &lt; Agent99::Base\n  # Inherits default logger, message_client, and registry_client\nend\n</code></pre> <ol> <li>Customizing Initialization: If you need custom initialization, you can ignore the <code>init</code> method and override the <code>initialize</code> method:</li> </ol> <pre><code>class MyCustomAgent &lt; Agent99::Base\n  def initialize(\n      registry_client:  CustomRegistryClient.new,\n      message_client:   CustomMessageClient.new,\n      logger:           Logger.new('custom_agent.log')\n    )\n    super  # Registers the Agent and setups its message queue\n\n    # Additional state or resource initialization required\n    # by the new agent\n  end\nend\n</code></pre> <p>In this case, the custom agent not need the <code>init</code> method to perform any additional setup.</p>"},{"location":"core-concepts/agent-lifecycle/#the-fini-method","title":"The <code>fini</code> Method","text":"<p>The <code>fini</code> method is setup to be invoked when the <code>exit</code> method is called within <code>initialize</code> method by the <code>on_exit { fini }</code> hook.</p> <p>The <code>fini</code> method ensures proper cleanup during agent shutdown:</p> <p>The default <code>fini</code> method does: - Withdrawing from the registry - Closing message queue connections</p> <p>If your agent requires additional cleanup or state presistence you should implement a custom <code>fini</code> method to do things like: - Cleaning up resources - Saving state (if required) - Releasing system resources</p> <p>Example implementation:</p> <pre><code>def fini\n  save_state if @state\n  cleanup_resources\n  deregister_from_registry\n\n  super  # Always call super last for proper framework cleanup\nend\n</code></pre>"},{"location":"core-concepts/agent-lifecycle/#best-practices","title":"Best Practices","text":"<ol> <li>Proper Method Ordering:</li> <li>Always call <code>super</code> first in <code>initialize</code>.</li> <li>Always call <code>super</code> last in <code>fini</code>.</li> <li> <p>This order ensures proper framework initialization and cleanup.</p> </li> <li> <p>Resource Management:</p> </li> <li>Initialize all resources in <code>init</code> or <code>initialize</code>.</li> <li>Clean up all resources in <code>fini</code>.</li> <li> <p>Handle cleanup idempotently.</p> </li> <li> <p>Error Handling:</p> </li> <li>Implement robust error handling in all methods.</li> <li>Ensure <code>fini</code> can handle partial initialization states.</li> <li> <p>Log all significant lifecycle events.</p> </li> <li> <p>State Management:</p> </li> <li>Initialize state clearly.</li> <li>Save or cleanup state properly in <code>fini</code>.</li> <li>Consider persistence needs.</li> </ol>"},{"location":"core-concepts/agent-lifecycle/#important-considerations","title":"Important Considerations","text":"<ul> <li>Agents can be implemented as stand-alone processes.</li> <li>When an agent is implemented within the context of a larger application process, the agent should be \"run\" within its own thread.     <pre><code>begin\n  my_agent = MyAgent.new\n  Thread.new { my_agent.run }\nend\n</code></pre></li> <li>Agents handle only one request message at a time.</li> <li>The <code>fini</code> method is called automatically during graceful shutdowns.</li> </ul>"},{"location":"core-concepts/agent-lifecycle/#framework-integration","title":"Framework Integration","text":"<p>The Agent99 framework automatically manages the lifecycle of agents:</p> <ol> <li>Calls <code>init</code> (if present) after agent creation.</li> <li>Monitors agent health during operation.</li> <li>Calls <code>fini</code> during shutdown (<code>on_exit {fini}</code>).</li> <li>Handles cleanup if initialization fails.</li> </ol> <p>This automated lifecycle management ensures reliable agent operation within the framework.</p>"},{"location":"core-concepts/agent-types/","title":"Agent Types","text":"<p>Agent99 supports three fundamental agent types, each designed for different communication patterns and use cases. Understanding these types is crucial for designing effective distributed systems.</p>"},{"location":"core-concepts/agent-types/#overview","title":"Overview","text":""},{"location":"core-concepts/agent-types/#server-agents","title":"Server Agents","text":"<p>Server agents receive and respond to requests from other agents. They're the workhorses of the Agent99 ecosystem.</p>"},{"location":"core-concepts/agent-types/#characteristics","title":"Characteristics","text":"<ul> <li>Reactive: Wait for incoming requests</li> <li>Stateless: Each request is handled independently (by default)</li> <li>Specialized: Usually focus on specific capabilities</li> <li>Discoverable: Register their capabilities for others to find</li> </ul>"},{"location":"core-concepts/agent-types/#example-server-agent","title":"Example: Server Agent","text":"<pre><code>class WeatherAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,  # This makes it a server agent\n      capabilities: ['weather', 'forecast', 'temperature']\n    }\n  end\n\n  def process_request(payload)\n    location = payload.dig(:location)\n\n    # Simulate weather lookup\n    weather_data = {\n      location: location,\n      temperature: rand(15..35),\n      condition: ['sunny', 'cloudy', 'rainy'].sample,\n      timestamp: Time.now.iso8601\n    }\n\n    send_response(weather_data)\n  end\nend\n</code></pre>"},{"location":"core-concepts/agent-types/#when-to-use-server-agents","title":"When to Use Server Agents","text":"<ul> <li>Services: Database access, calculations, data processing</li> <li>APIs: Wrapping external APIs or services  </li> <li>Workers: Background job processing</li> <li>Specialists: Domain-specific functionality</li> </ul>"},{"location":"core-concepts/agent-types/#client-agents","title":"Client Agents","text":"<p>Client agents make requests to other agents and handle their responses. They're the initiators of communication.</p>"},{"location":"core-concepts/agent-types/#characteristics_1","title":"Characteristics","text":"<ul> <li>Proactive: Initiate communication</li> <li>Discovery-aware: Find and connect to appropriate services</li> <li>Request-driven: Send requests and wait for responses</li> <li>Orchestrating: Can coordinate multiple service calls</li> </ul>"},{"location":"core-concepts/agent-types/#example-client-agent","title":"Example: Client Agent","text":"<pre><code>class WeatherClientAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :client,  # This makes it a client agent\n      capabilities: ['weather_requester', 'data_aggregator']\n    }\n  end\n\n  def get_weather_report(locations)\n    # Find weather service agents\n    weather_agents = discover_agents(['weather'])\n\n    if weather_agents.empty?\n      logger.warn \"No weather agents available\"\n      return nil\n    end\n\n    weather_agent = weather_agents.first\n    reports = []\n\n    locations.each do |location|\n      request = { location: location }\n      response = send_request(weather_agent[:name], request)\n      reports &lt;&lt; response if response\n    end\n\n    reports\n  end\nend\n</code></pre>"},{"location":"core-concepts/agent-types/#when-to-use-client-agents","title":"When to Use Client Agents","text":"<ul> <li>Aggregators: Combine data from multiple sources</li> <li>Workflows: Multi-step business processes</li> <li>User Interfaces: Frontend applications</li> <li>Schedulers: Time-based or event-driven tasks</li> </ul>"},{"location":"core-concepts/agent-types/#hybrid-agents","title":"Hybrid Agents","text":"<p>Hybrid agents can both send and receive requests. They're the most flexible but also the most complex.</p>"},{"location":"core-concepts/agent-types/#characteristics_2","title":"Characteristics","text":"<ul> <li>Bidirectional: Can act as both client and server</li> <li>Mediating: Often serve as intermediaries or proxies</li> <li>Stateful: May maintain state across interactions</li> <li>Complex: Handle multiple communication patterns</li> </ul>"},{"location":"core-concepts/agent-types/#example-hybrid-agent","title":"Example: Hybrid Agent","text":"<pre><code>class WeatherProxyAgent &lt; Agent99::Base\n  def initialize\n    super\n    @cache = {}  # Simple caching\n    @stats = { requests: 0, cache_hits: 0 }\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :hybrid,  # This makes it a hybrid agent\n      capabilities: ['weather_proxy', 'caching', 'analytics']\n    }\n  end\n\n  # Server behavior: respond to weather requests\n  def process_request(payload)\n    location = payload.dig(:location)\n    @stats[:requests] += 1\n\n    # Check cache first\n    if @cache[location] &amp;&amp; fresh_enough?(@cache[location])\n      @stats[:cache_hits] += 1\n      logger.info \"Cache hit for #{location}\"\n      send_response(@cache[location][:data])\n      return\n    end\n\n    # Cache miss - get from weather service\n    weather_data = fetch_weather_data(location)\n\n    if weather_data\n      @cache[location] = {\n        data: weather_data,\n        timestamp: Time.now\n      }\n      send_response(weather_data)\n    else\n      send_error(\"Weather data unavailable for #{location}\")\n    end\n  end\n\n  # Client behavior: request from actual weather service\n  private def fetch_weather_data(location)\n    weather_agents = discover_agents(['weather'])\n    return nil if weather_agents.empty?\n\n    weather_agent = weather_agents.first\n    request = { location: location }\n    send_request(weather_agent[:name], request)\n  end\n\n  private def fresh_enough?(cache_entry)\n    Time.now - cache_entry[:timestamp] &lt; 300  # 5 minutes\n  end\n\n  # Additional hybrid behavior: provide statistics\n  def get_statistics\n    {\n      total_requests: @stats[:requests],\n      cache_hits: @stats[:cache_hits],\n      cache_hit_rate: @stats[:requests] &gt; 0 ? @stats[:cache_hits].to_f / @stats[:requests] : 0\n    }\n  end\nend\n</code></pre>"},{"location":"core-concepts/agent-types/#when-to-use-hybrid-agents","title":"When to Use Hybrid Agents","text":"<ul> <li>Proxies: Caching, load balancing, protocol translation</li> <li>Middleware: Authentication, logging, monitoring</li> <li>State Managers: Session management, workflow coordination</li> <li>Aggregators: Collect, process, and redistribute data</li> </ul>"},{"location":"core-concepts/agent-types/#agent-type-comparison","title":"Agent Type Comparison","text":"Feature Server Client Hybrid Receives Requests \u2705 \u274c \u2705 Sends Requests \u274c \u2705 \u2705 Complexity Low Medium High Statefulness Usually stateless Can be stateful Often stateful Use Cases Services, APIs UIs, Schedulers Proxies, Middleware"},{"location":"core-concepts/agent-types/#communication-patterns","title":"Communication Patterns","text":""},{"location":"core-concepts/agent-types/#request-response-serverclient","title":"Request-Response (Server/Client)","text":""},{"location":"core-concepts/agent-types/#proxy-pattern-hybrid","title":"Proxy Pattern (Hybrid)","text":""},{"location":"core-concepts/agent-types/#best-practices","title":"Best Practices","text":""},{"location":"core-concepts/agent-types/#server-agents_1","title":"Server Agents","text":"<ol> <li>Keep them focused: One capability per agent</li> <li>Make them stateless: Each request independent</li> <li>Validate inputs: Use schemas for safety</li> <li>Handle errors gracefully: Always respond, even on error</li> </ol>"},{"location":"core-concepts/agent-types/#client-agents_1","title":"Client Agents","text":"<ol> <li>Handle service unavailability: Graceful degradation</li> <li>Use timeouts: Don't wait forever</li> <li>Implement retries: With exponential backoff</li> <li>Cache discoveries: Don't rediscover every time</li> </ol>"},{"location":"core-concepts/agent-types/#hybrid-agents_1","title":"Hybrid Agents","text":"<ol> <li>Separate concerns: Clear distinction between client/server logic</li> <li>Manage state carefully: Consider thread safety</li> <li>Monitor performance: Track both directions</li> <li>Document behavior: Complex interactions need clear docs</li> </ol>"},{"location":"core-concepts/agent-types/#choosing-the-right-type","title":"Choosing the Right Type","text":"<p>Ask yourself:</p> <ul> <li>Do I need to respond to requests? \u2192 Server or Hybrid</li> <li>Do I need to make requests? \u2192 Client or Hybrid  </li> <li>Do I need both? \u2192 Hybrid</li> <li>Is simplicity important? \u2192 Avoid Hybrid if possible</li> <li>Is this a leaf service? \u2192 Probably Server</li> <li>Is this an orchestrator? \u2192 Probably Client</li> <li>Is this middleware? \u2192 Probably Hybrid</li> </ul>"},{"location":"core-concepts/agent-types/#next-steps","title":"Next Steps","text":"<ul> <li>Agent Lifecycle - How agents start, run, and stop</li> <li>Architecture Overview - How agents fit into the bigger picture</li> <li>Custom Agent Implementation - Build your own agents</li> </ul>"},{"location":"core-concepts/architecture/","title":"Agent99 Framework Architecture","text":""},{"location":"core-concepts/architecture/#high-level-architecture-overview","title":"High-Level Architecture Overview","text":"<p>Agent99 is a Ruby-based framework designed for building and managing software agents in a distributed system environment. The architecture follows a service-oriented approach with three main components:</p> <ol> <li>Agents: Independent services that can register, discover, and communicate with each other</li> <li>Registry Service: Central registration and discovery system</li> <li>Message Broker: Communication backbone (supports AMQP or NATS)</li> </ol>"},{"location":"core-concepts/architecture/#system-components-diagram","title":"System Components Diagram","text":"<p>The diagram above illustrates the key components and their interactions:</p> <ul> <li>Agents: Come in three types:</li> <li>Client Agents: Only make requests</li> <li>Server Agents: Only respond to requests</li> <li> <p>Hybrid Agents: Both make and respond to requests</p> </li> <li> <p>Registry Service: </p> </li> <li>Maintains agent registrations</li> <li>Handles capability-based discovery</li> <li> <p>Issues unique UUIDs to agents</p> </li> <li> <p>Message Broker:</p> </li> <li>Supports both AMQP and NATS protocols</li> <li>Handles message routing between agents</li> <li>Provides reliable message delivery</li> </ul>"},{"location":"core-concepts/architecture/#communication-patterns","title":"Communication Patterns","text":"<ol> <li> <p>Registration Flow:</p> <ul> <li>New agent instantiated</li> <li>Agent registers with Registry Service</li> <li>Receives unique UUID for identification</li> <li>Sets up message queue/topic</li> </ul> </li> <li> <p>Discovery Flow:</p> <ul> <li>Agent queries Registry for specific capabilities</li> <li>Registry returns matching agent information</li> <li>Requesting agent caches discovery results</li> </ul> </li> <li> <p>Messaging Flow:</p> <ul> <li>Agent creates message with recipient UUID</li> <li>Message routed through Message Broker</li> <li>Recipient processes message based on type:<ul> <li>Requests: Handled by receive_request</li> <li>Responses: Handled by receive_response</li> <li>Control: Handled by control handlers</li> </ul> </li> </ul> </li> </ol>"},{"location":"core-concepts/architecture/#message-types","title":"Message Types","text":"<p>The framework supports three primary message types:</p> <ol> <li> <p>Request Messages: </p> <ul> <li>Used to request services from other agents</li> <li>Must include capability requirements</li> <li>Can contain arbitrary payload data</li> </ul> </li> <li> <p>Response Messages:</p> <ul> <li>Sent in reply to requests</li> <li>Include original request reference</li> <li>Contain result data or error information</li> </ul> </li> <li> <p>Control Messages:</p> <ul> <li>System-level communication</li> <li>Handle agent lifecycle events</li> <li>Support configuration updates</li> </ul> </li> </ol>"},{"location":"core-concepts/architecture/#implementation-details","title":"Implementation Details","text":"<p>For detailed implementation information, see: - API Reference for method specifications - Agent Lifecycle for lifecycle management - Agent Discovery for discovery mechanisms</p>"},{"location":"core-concepts/what-is-an-agent/","title":"What is an Agent?","text":"<p>An agent is a self-contained piece of code designed to perform a specific function or service. Unlike general-purpose classes or modules, agents can be autonomous entities that focus on doing one thing well. They embody the Single Responsibility Principle (SRP) by design.</p> <p>I will be using the Ruby programming language and the agent99 gem specifically to illustrate aspects of what I think good software agents should look like.  I choose Ruby because:</p> <ul> <li>Ruby allows developers to create elegant and expressive AI applications.</li> <li>It promotes paradigm shifts, challenging the Python status quo in AI development.</li> <li>Developers who value clarity can find their niche in Ruby's design.</li> <li>Ruby's metaprogramming capabilities pave the way for creative AI solutions.</li> <li>Greater integration of Ruby-based frameworks makes them viable choices in the AI landscape.</li> <li>Ruby's object-oriented style leads to more modular and testable code.</li> <li>Ruby inspires a community that often prefers its syntax over Python's.</li> </ul>"},{"location":"core-concepts/what-is-an-agent/#getting-started-with-agent99","title":"Getting Started with Agent99","text":"<p>The <code>agent99</code> is a Ruby gem that serves as a framework for developing and managing software agents, allowing for the execution and communication of these agents in a distributed environment. It implements a reference protocol that supports agent registration, discovery, and messaging through a centralized registry and a messaging system like AMQP or NATS. Each agent, derived from the <code>Agent99::Base</code> class, is designed to perform specific tasks as defined by its capabilities, adhering to the Single Responsibility Principle (SRP) for enhanced maintainability and testability. The framework facilitates modular agent interactions, enabling developers to build innovative applications while taking advantage of Ruby\u2019s expressive syntax and metaprogramming features. The library emphasizes best practices in software design, including error handling and lifecycle management for robust agent operations.</p> <p>To install the Agent99 gem, simply run:</p> <pre><code>gem install agent99\n</code></pre> <p>The documentation provides a comprehensive overview of the framework, but here, we will explore definitions of software agents and the Single Responsibility Principle (SRP), along with how Agent99 distinguishes itself in agent management and description.</p>"},{"location":"core-concepts/what-is-an-agent/#what-is-a-reference-implementation","title":"What Is a Reference Implementation?","text":"<p>The Agent99 gem implements a protocol in Ruby that can be replicated in other programming languages. This interoperability allows software agents, given they support the Agent99 protocol, to mix and match regardless of the language they were built in.</p>"},{"location":"core-concepts/what-is-an-agent/#understanding-software-agents-and-the-single-responsibility-principle","title":"Understanding Software Agents and the Single Responsibility Principle","text":"<p>Software agents and the Single Responsibility Principle (SRP) are crucial in contemporary software development. They decompose complex systems into manageable, autonomous components, while SRP promotes the creation of maintainable, testable, and adaptable systems. Utilizing both can boost code quality and nurture agility in development teams, particularly in AI, automation, and microservices contexts.</p>"},{"location":"core-concepts/what-is-an-agent/#what-are-software-agents","title":"What Are Software Agents?","text":"<p>In simple terms, a software agent is a designated piece of code that performs a single function effectively. Within the Agent99 framework, agents are instances of subclasses derived from the Agent99::Base class. These instances can be running in their own separate process or groups of instances of different Agent99 instances can run within separate Threads in a single process.</p> <p>Here's a simple example of an Agent99 agent class running in an independent process:</p> <pre><code># File: example_agent.rb\n\nrequire 'agent99'\n\nclass ExampleAgent &lt; Agent99::Base\n  def info\n    {\n      name:             self.class.to_s,\n      type:             :server,\n      capabilities:     %w[ rubber_stamp yes_man example ],\n      # request_schema:   {}, # ExampleRequest.schema,\n      # response_schema:  {}, # Agent99::RESPONSE.schema\n      # control_schema:   {}, # Agent99::CONTROL.schema\n      # error_schema:     {}, # Agent99::ERROR.schema\n    }\n  end  \n\n  def receive_request\n    logger.info \"Example agent received request: #{payload}\"\n    send_response(status: 'success')\n  end\nend\n\nExampleAgent.new.run\n</code></pre> <pre><code>ruby example_agent.rb\n</code></pre> <p>Each agent subclass is responsible for specific methods that define its unique capabilities and how it handles requests.  The <code>info</code> method provides a comprehensive information packet about the agent. It returns a hash containing key details that are crucial for agent registration and discovery within the system.  The :capabilities entry in the <code>info</code> packet in an Array of Strings - synonyms - for the thing that the agent does.</p> <p>For a server type agent, the only methods that are required to be defined, as in the ExampleAgent class above, are its info and its receive_request methods. Everything else from initialization, registration, message dispatching, and graceful shutdown are handled by the default methods within the Agent99::Base class.</p> <p>More complex agents will require methods like receive_response and receive_control and potentially custom implementations of init, initialize, or fini may be necessary for managing state or resources.</p> <p>RoadMap: Currently, the Agent99 implementation defines the capabilities value as an <code>Array(String)</code>, with plans to enhance this functionality into descriptive unstructured text akin to defining tools for functional callbacks in LLM processing using semantic search.</p>"},{"location":"core-concepts/what-is-an-agent/#the-single-responsibility-principle-srp","title":"The Single Responsibility Principle (SRP)","text":"<p>The Single Responsibility Principle, part of the SOLID principles of object-oriented design, asserts that a class or module should have only one reason to change. This means it should fulfill a single job or responsibility effectively.</p>"},{"location":"core-concepts/what-is-an-agent/#why-srp-matters","title":"Why SRP Matters","text":"<ol> <li>Maintainability: Code is easier to read and modify, leading to more maintainable systems.</li> <li>Testability: Isolated responsibilities facilitate independent unit testing.</li> <li>Flexibility: Minimal impact on other parts of the system when modifying one responsibility, reducing the risk of bugs.</li> </ol>"},{"location":"core-concepts/what-is-an-agent/#applying-srp-in-software-development","title":"Applying SRP in Software Development","text":"<p>Implementing SRP involves:</p> <ul> <li>Identifying Responsibilities: Break down functionalities into specific tasks; each class or module should focus on a particular duty.</li> <li>Modular Design: Create a loosely coupled system to enhance separation of concerns.</li> <li>Utilizing Design Patterns: Harness design patterns like Observer, Strategy, and Factory to ensure clear interfaces and responsibilities.</li> </ul>"},{"location":"core-concepts/what-is-an-agent/#alignment-of-agents-and-srp","title":"Alignment of Agents and SRP","text":"<p>The notion of software agents naturally corresponds with the SRP. Each agent can be a distinct class or module that encapsulates a specific functionality. For instance:</p> <ul> <li>An order processing agent focuses solely on order management.</li> <li>A notification agent manages the sending of alerts or messages without getting involved in order processing logic.</li> </ul> <p>Designing agents with SRP in mind fosters modularity and reusability, allowing changes to one agent without affecting others and supporting more robust architecture.</p>"},{"location":"core-concepts/what-is-an-agent/#agent99-as-a-reference-framework","title":"Agent99 as a Reference Framework","text":"<p>In its current iteration, the Agent99 Framework does not differ conceptually from other microservice architecture implementations. It enables centralized registration where agents list their capabilities for other agents or applications to discover. Agent communications occur via a distributed messaging system. The agent99 Ruby gem currently uses AMQP (via the Bunny gem and the RabbitMQ broker) and the NATS-server.</p>"},{"location":"core-concepts/what-is-an-agent/#agent-structure","title":"Agent Structure","text":"<p>Agents in Agent99 inherit from Agent99::Base, which offers core functionality through crucial modules:</p> <ul> <li>HeaderManagement: Handles message header processing.</li> <li>AgentDiscovery: Facilitates capability advertisement and discovery.</li> <li>ControlActions: Manages control messages.</li> <li>AgentLifecycle: Oversees agent startup and shutdown functionality.</li> <li>MessageProcessing: Manages message dispatch and handling.</li> </ul> <p>Every agent must define its type (server, client, or hybrid) and capabilities. The framework supports three message types: requests, responses, and control messages.</p> <pre><code>class Agent99::Base\n  include Agent99::HeaderManagement\n  include Agent99::AgentDiscovery\n  include Agent99::ControlActions\n  include Agent99::AgentLifecycle\n  include Agent99::MessageProcessing\n\n  MESSAGE_TYPES = %w[request response control]\n\n  attr_reader :id, :capabilities, :name, :payload, :header, :logger, :queue\n  attr_accessor :registry_client, :message_client\n\n  ###################################################\n  private\n\n  def handle_error(message, error)\n    logger.error \"#{message}: #{error.message}\"\n    logger.debug error.backtrace.join(\"\\n\")\n  end\n\n  # the final rescue block\n  rescue StandardError =&gt; e\n    handle_error(\"Unhandled error in Agent99::Base\", e)\n    exit(2)\nend\n</code></pre>"},{"location":"core-concepts/what-is-an-agent/#centralized-registry","title":"Centralized Registry","text":"<p>The registry service tracks agent availability and capabilities through a RegistryClient. A web-based application serves as the central registry, with a Sinatra implementation found in the <code>examples/registry.rb</code> file. Its primary function is to maintain a data store of registered agents.</p> <p>It supports three core operations:</p>"},{"location":"core-concepts/what-is-an-agent/#1-register","title":"1. Register","text":"<p>Agents register by providing their information (e.g., name and capabilities) to the registry service. Here's how registration works in practice:</p> <pre><code>class WeatherAgent &lt; Agent99::Base\n  TYPE = :server\n\n  def capabilities\n    %w[get_temperature get_forecast]\n  end\n\n  def receive_request(message)\n    case message.payload[:action]\n    when 'get_temperature'\n      send_response({ temperature: 72, unit: 'F' })\n    when 'get_forecast'\n      send_response({ forecast: 'Sunny with a chance of rain' })\n    end\n  end\nend\n\n# Start the agent\nWeatherAgent.new.run\n</code></pre> <p>Upon successful registration, agents receive a universally unique ID (UUID) that identifies them in the system. The registration process is handled automatically by the Agent99 framework when you call <code>run</code>.</p>"},{"location":"core-concepts/what-is-an-agent/#2-discover","title":"2. Discover","text":"<p>Agents can query the registry to discover capabilities. The discovery operation retrieves information about agents offering specific capabilities via an HTTP GET request.</p>"},{"location":"core-concepts/what-is-an-agent/#3-withdraw","title":"3. Withdraw","text":"<p>When an agent needs to exit the system, it withdraws its registration using its UUID, removing it from the available agents list through an HTTP DELETE request.</p>"},{"location":"core-concepts/what-is-an-agent/#messaging-network","title":"Messaging Network","text":"<p>The Ruby implementation of Agent99 currently focuses on AMQP messaging systems. Messages are formatted as JSON structures that adhere to defined schemas, allowing the MessageClient to validate messages effortlessly.</p> <p>Messages are validated against defined schemas, and invalid messages return to the sender without invoking agent-specific processes.</p> <p>Message types within the framework include:</p>"},{"location":"core-concepts/what-is-an-agent/#request-messages","title":"Request Messages","text":"<p>These messages are validated against an agent-defined schema and include:</p> <ul> <li>A header with routing information.</li> <li>Agent-specific elements with their types and examples.</li> </ul> <p>Requests are handled by the <code>receive_request</code> handler in target agents.</p> <p>Here's an example of a request message schema using the SimpleJsonSchemaBuilder gem</p> <pre><code># examples/maxwell_request.rb\n\nrequire 'agent99/header_schema'\n\nclass MaxwellRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n\n    string :greeting, required: false, examples: [\"Hello\"]\n    string :name,     required: true,  examples: [\"World\"]\n  end\nend\n</code></pre> <p>This schema defines a <code>MaxwellRequest</code> with a header (using the <code>Agent99::HeaderSchema</code>), an optional greeting, and a required name. A valid JSON message conforming to this schema might look like:</p> <pre><code>{\n  \"header\": {\n    \"from_uuid\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"to_uuid\": \"987e6543-e21b-12d3-a456-426614174000\",\n    \"message_id\": \"msg-001\",\n    \"correlation_id\": \"corr-001\",\n    \"timestamp\": \"2023-04-01T12:00:00Z\"\n  },\n  \"greeting\": \"Hello\",\n  \"name\": \"Agent99\"\n}\n</code></pre> <p>Using such schemas ensures that messages are well-structured and contain all necessary information before being processed by agents.</p> <p>Here is how the MaxwellAgent associates itself with its specific request schema:</p> <pre><code># examples/maxwell_agent86.rb\n\nrequire 'agent99'\nrequire_relative 'maxwell_request'\n\nclass MaxwellAgent86 &lt; Agent99::Base\n  def info\n    {\n      # ...\n      request_schema: MaxwellRequest.schema,\n      # ...\n    }\n  end\n</code></pre> <p>When an agent subclass defines a :request_schema in its <code>info</code>, the message processing of the Agent99::Base validates all incoming requests against the schema. If there are errors, those errors are returned to the sender without presenting the request message to the agent's custom receive_request method.</p>"},{"location":"core-concepts/what-is-an-agent/#response-messages","title":"Response Messages","text":"<p>Responses are routed back to the requesting agent and include:</p> <ul> <li>The original message header in reverse.</li> <li>The response payload.</li> <li>Status information.</li> </ul> <p>Responses are processed by the <code>receive_response</code> method.</p>"},{"location":"core-concepts/what-is-an-agent/#control-messages","title":"Control Messages","text":"<p>Control messages manage agent lifecycles and configurations and include commands such as:</p> <ul> <li>shutdown: Stop the agent.</li> <li>pause/resume: Temporarily suspend or resume operations.</li> <li>update_config: Modify agent configurations.</li> <li>status: Query agent state.</li> <li>response: Handle control operation results.</li> </ul> <p>Messages are queued with a 60-second TTL (Time To Live) to prevent buildup from inactive agents.</p>"},{"location":"core-concepts/what-is-an-agent/#additional-resources","title":"Additional Resources","text":"<p>For further exploration, check out the documentation of the current Ruby implementation at GitHub.</p> <p>Contributions to this initial Ruby reference implementation are welcome! It would be exciting to see additional language implementations.</p>"},{"location":"examples/advanced-examples/","title":"Advanced Examples","text":"<p>This section contains advanced examples demonstrating sophisticated Agent99 patterns, distributed architectures, and real-world use cases.</p>"},{"location":"examples/advanced-examples/#microservices-architecture-example","title":"Microservices Architecture Example","text":"<p>A complete e-commerce microservices system using Agent99:</p>"},{"location":"examples/advanced-examples/#order-processing-service","title":"Order Processing Service","text":"<pre><code>require 'agent99'\nrequire 'simple_json_schema_builder'\n\nclass OrderRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n    string :customer_id, required: true, format: :uuid\n    array :items, required: true, minItems: 1 do\n      object do\n        string :product_id, required: true, format: :uuid\n        integer :quantity, required: true, minimum: 1\n        number :unit_price, required: true, minimum: 0\n      end\n    end\n    object :shipping_address, required: true do\n      string :street, required: true\n      string :city, required: true\n      string :state, required: true\n      string :zip_code, required: true\n      string :country, required: true\n    end\n  end\nend\n\nclass OrderProcessingAgent &lt; Agent99::Base\n  def initialize\n    super\n    @orders = {}\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :hybrid,\n      capabilities: ['order_processing', 'e_commerce'],\n      request_schema: OrderRequest.schema\n    }\n  end\n\n  def process_request(payload)\n    order_id = SecureRandom.uuid\n\n    # Validate inventory\n    inventory_check = check_inventory(payload[:items])\n    unless inventory_check[:available]\n      return send_error(\"Insufficient inventory\", \"INVENTORY_ERROR\", inventory_check)\n    end\n\n    # Process payment\n    payment_result = process_payment(payload[:customer_id], inventory_check[:total])\n    unless payment_result[:success]\n      return send_error(\"Payment failed\", \"PAYMENT_ERROR\", payment_result)\n    end\n\n    # Create order\n    order = create_order(order_id, payload, payment_result)\n\n    # Trigger fulfillment\n    trigger_fulfillment(order)\n\n    # Send notifications\n    notify_customer(order)\n\n    send_response(\n      order_id: order_id,\n      status: 'confirmed',\n      total: inventory_check[:total],\n      estimated_delivery: (Time.now + 7.days).iso8601\n    )\n  end\n\n  private\n\n  def check_inventory(items)\n    inventory_agents = discover_agents(['inventory'])\n    return { available: false, error: 'No inventory service' } if inventory_agents.empty?\n\n    inventory_agent = inventory_agents.first\n    total = 0\n\n    items.each do |item|\n      request = {\n        product_id: item[:product_id],\n        quantity: item[:quantity]\n      }\n\n      response = send_request(inventory_agent[:name], request)\n      unless response &amp;&amp; response[:available]\n        return {\n          available: false,\n          product_id: item[:product_id],\n          error: 'Insufficient stock'\n        }\n      end\n\n      total += item[:unit_price] * item[:quantity]\n    end\n\n    { available: true, total: total }\n  end\n\n  def process_payment(customer_id, amount)\n    payment_agents = discover_agents(['payment'])\n    return { success: false, error: 'No payment service' } if payment_agents.empty?\n\n    payment_agent = payment_agents.first\n    request = {\n      customer_id: customer_id,\n      amount: amount,\n      currency: 'USD'\n    }\n\n    response = send_request(payment_agent[:name], request)\n    response || { success: false, error: 'Payment service unavailable' }\n  end\n\n  def create_order(order_id, payload, payment_result)\n    order = {\n      id: order_id,\n      customer_id: payload[:customer_id],\n      items: payload[:items],\n      shipping_address: payload[:shipping_address],\n      payment_id: payment_result[:payment_id],\n      total: payment_result[:amount],\n      status: 'confirmed',\n      created_at: Time.now.iso8601\n    }\n\n    @orders[order_id] = order\n    order\n  end\n\n  def trigger_fulfillment(order)\n    fulfillment_agents = discover_agents(['fulfillment'])\n    return unless fulfillment_agents.any?\n\n    fulfillment_agent = fulfillment_agents.first\n    request = {\n      order_id: order[:id],\n      items: order[:items],\n      shipping_address: order[:shipping_address]\n    }\n\n    # Async fulfillment request\n    Thread.new do\n      send_request(fulfillment_agent[:name], request)\n    end\n  end\n\n  def notify_customer(order)\n    notification_agents = discover_agents(['notification'])\n    return unless notification_agents.any?\n\n    notification_agent = notification_agents.first\n    request = {\n      type: 'order_confirmation',\n      customer_id: order[:customer_id],\n      order_id: order[:id],\n      template_data: {\n        order_total: order[:total],\n        item_count: order[:items].size\n      }\n    }\n\n    # Async notification\n    Thread.new do\n      send_request(notification_agent[:name], request)\n    end\n  end\nend\n</code></pre>"},{"location":"examples/advanced-examples/#inventory-management-service","title":"Inventory Management Service","text":"<pre><code>class InventoryAgent &lt; Agent99::Base\n  def initialize\n    super\n    @inventory = load_inventory_data\n    @mutex = Mutex.new\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['inventory', 'stock_management']\n    }\n  end\n\n  def process_request(payload)\n    product_id = payload.dig(:product_id)\n    quantity = payload.dig(:quantity)\n\n    @mutex.synchronize do\n      product = @inventory[product_id]\n\n      unless product\n        return send_error(\"Product not found\", \"PRODUCT_NOT_FOUND\")\n      end\n\n      available_quantity = product[:stock]\n\n      if available_quantity &gt;= quantity\n        # Reserve stock\n        @inventory[product_id][:stock] -= quantity\n        @inventory[product_id][:reserved] += quantity\n\n        send_response(\n          available: true,\n          product_id: product_id,\n          reserved_quantity: quantity,\n          remaining_stock: @inventory[product_id][:stock]\n        )\n      else\n        send_response(\n          available: false,\n          product_id: product_id,\n          requested_quantity: quantity,\n          available_quantity: available_quantity\n        )\n      end\n    end\n  end\n\n  private\n\n  def load_inventory_data\n    # Simulate inventory database\n    {\n      SecureRandom.uuid =&gt; { name: 'Widget A', stock: 100, reserved: 0, price: 29.99 },\n      SecureRandom.uuid =&gt; { name: 'Widget B', stock: 50, reserved: 0, price: 39.99 },\n      SecureRandom.uuid =&gt; { name: 'Widget C', stock: 25, reserved: 0, price: 49.99 }\n    }\n  end\nend\n</code></pre>"},{"location":"examples/advanced-examples/#payment-processing-service","title":"Payment Processing Service","text":"<pre><code>class PaymentAgent &lt; Agent99::Base\n  def initialize\n    super\n    @payments = {}\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['payment', 'billing']\n    }\n  end\n\n  def process_request(payload)\n    customer_id = payload.dig(:customer_id)\n    amount = payload.dig(:amount)\n    currency = payload.dig(:currency, 'USD')\n\n    # Simulate payment processing\n    payment_id = SecureRandom.uuid\n\n    # Simulate occasional payment failures\n    if rand &lt; 0.05 # 5% failure rate\n      return send_error(\"Payment declined\", \"PAYMENT_DECLINED\", {\n        reason: 'insufficient_funds',\n        payment_id: payment_id\n      })\n    end\n\n    # Process payment\n    payment_result = {\n      payment_id: payment_id,\n      customer_id: customer_id,\n      amount: amount,\n      currency: currency,\n      status: 'completed',\n      processed_at: Time.now.iso8601,\n      transaction_id: \"txn_#{SecureRandom.hex(8)}\"\n    }\n\n    @payments[payment_id] = payment_result\n\n    send_response(\n      success: true,\n      payment_id: payment_id,\n      amount: amount,\n      transaction_id: payment_result[:transaction_id]\n    )\n  end\nend\n</code></pre>"},{"location":"examples/advanced-examples/#event-driven-architecture-example","title":"Event-Driven Architecture Example","text":"<p>Implementing an event-driven system with Agent99:</p>"},{"location":"examples/advanced-examples/#event-bus-agent","title":"Event Bus Agent","text":"<pre><code>class EventBusAgent &lt; Agent99::Base\n  def initialize\n    super\n    @subscribers = {}\n    @events = []\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :hybrid,\n      capabilities: ['event_bus', 'pub_sub', 'messaging']\n    }\n  end\n\n  def process_request(payload)\n    action = payload.dig(:action)\n\n    case action\n    when 'publish'\n      publish_event(payload)\n    when 'subscribe'\n      subscribe_to_events(payload)\n    when 'get_events'\n      get_events(payload)\n    else\n      send_error(\"Unknown action: #{action}\", \"INVALID_ACTION\")\n    end\n  end\n\n  private\n\n  def publish_event(payload)\n    event = {\n      id: SecureRandom.uuid,\n      type: payload[:event_type],\n      source: payload[:source],\n      data: payload[:data],\n      timestamp: Time.now.iso8601\n    }\n\n    @events &lt;&lt; event\n\n    # Notify subscribers\n    subscribers = @subscribers[event[:type]] || []\n    subscribers.each do |subscriber|\n      notify_subscriber(subscriber, event)\n    end\n\n    send_response(\n      event_id: event[:id],\n      published: true,\n      subscribers_notified: subscribers.size\n    )\n  end\n\n  def subscribe_to_events(payload)\n    event_type = payload[:event_type]\n    subscriber = payload[:subscriber]\n\n    @subscribers[event_type] ||= []\n    @subscribers[event_type] &lt;&lt; subscriber unless @subscribers[event_type].include?(subscriber)\n\n    send_response(\n      subscribed: true,\n      event_type: event_type,\n      subscriber: subscriber\n    )\n  end\n\n  def get_events(payload)\n    event_type = payload[:event_type]\n    since = payload[:since] ? Time.parse(payload[:since]) : (Time.now - 3600)\n\n    filtered_events = @events.select do |event|\n      (event_type.nil? || event[:type] == event_type) &amp;&amp;\n      Time.parse(event[:timestamp]) &gt;= since\n    end\n\n    send_response(\n      events: filtered_events,\n      count: filtered_events.size\n    )\n  end\n\n  def notify_subscriber(subscriber, event)\n    Thread.new do\n      begin\n        agents = discover_agents([subscriber])\n        if agents.any?\n          agent = agents.first\n          send_request(agent[:name], {\n            action: 'handle_event',\n            event: event\n          })\n        end\n      rescue =&gt; e\n        logger.error \"Failed to notify subscriber #{subscriber}: #{e.message}\"\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"examples/advanced-examples/#event-subscriber-example","title":"Event Subscriber Example","text":"<pre><code>class AuditAgent &lt; Agent99::Base\n  def initialize\n    super\n    @audit_log = []\n    subscribe_to_events\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :hybrid,\n      capabilities: ['audit', 'logging', 'compliance']\n    }\n  end\n\n  def process_request(payload)\n    action = payload.dig(:action)\n\n    case action\n    when 'handle_event'\n      handle_event(payload[:event])\n    when 'get_audit_log'\n      get_audit_log(payload)\n    else\n      send_error(\"Unknown action: #{action}\", \"INVALID_ACTION\")\n    end\n  end\n\n  private\n\n  def subscribe_to_events\n    event_bus_agents = discover_agents(['event_bus'])\n    return unless event_bus_agents.any?\n\n    event_bus = event_bus_agents.first\n\n    # Subscribe to various event types\n    %w[order_created payment_processed user_login].each do |event_type|\n      send_request(event_bus[:name], {\n        action: 'subscribe',\n        event_type: event_type,\n        subscriber: 'audit'\n      })\n    end\n  end\n\n  def handle_event(event)\n    audit_entry = {\n      id: SecureRandom.uuid,\n      event_id: event[:id],\n      event_type: event[:type],\n      source: event[:source],\n      timestamp: event[:timestamp],\n      data: event[:data],\n      processed_at: Time.now.iso8601\n    }\n\n    @audit_log &lt;&lt; audit_entry\n\n    # Log to file or database\n    File.open('audit.log', 'a') do |f|\n      f.puts audit_entry.to_json\n    end\n\n    send_response(\n      audit_id: audit_entry[:id],\n      logged: true\n    )\n  end\n\n  def get_audit_log(payload)\n    event_type = payload[:event_type]\n    since = payload[:since] ? Time.parse(payload[:since]) : (Time.now - 86400)\n\n    filtered_entries = @audit_log.select do |entry|\n      (event_type.nil? || entry[:event_type] == event_type) &amp;&amp;\n      Time.parse(entry[:timestamp]) &gt;= since\n    end\n\n    send_response(\n      audit_entries: filtered_entries,\n      count: filtered_entries.size\n    )\n  end\nend\n</code></pre>"},{"location":"examples/advanced-examples/#distributed-cache-example","title":"Distributed Cache Example","text":"<p>Building a distributed cache using multiple Agent99 agents:</p>"},{"location":"examples/advanced-examples/#cache-coordinator","title":"Cache Coordinator","text":"<pre><code>class CacheCoordinator &lt; Agent99::Base\n  def initialize\n    super\n    @ring = ConsistentHashRing.new\n    @cache_nodes = {}\n    discover_cache_nodes\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :hybrid,\n      capabilities: ['cache_coordinator', 'distributed_cache']\n    }\n  end\n\n  def process_request(payload)\n    operation = payload.dig(:operation)\n    key = payload.dig(:key)\n\n    case operation\n    when 'get'\n      get_from_cache(key)\n    when 'set'\n      set_in_cache(key, payload[:value], payload[:ttl])\n    when 'delete'\n      delete_from_cache(key)\n    when 'stats'\n      get_cache_stats\n    else\n      send_error(\"Unknown operation: #{operation}\", \"INVALID_OPERATION\")\n    end\n  end\n\n  private\n\n  def discover_cache_nodes\n    cache_nodes = discover_agents(['cache_node'])\n\n    cache_nodes.each do |node|\n      @ring.add_node(node[:name])\n      @cache_nodes[node[:name]] = node\n    end\n\n    logger.info \"Discovered #{cache_nodes.size} cache nodes\"\n  end\n\n  def get_from_cache(key)\n    node_name = @ring.get_node(key)\n    node = @cache_nodes[node_name]\n\n    return send_error(\"No cache nodes available\", \"NO_CACHE_NODES\") unless node\n\n    response = send_request(node[:name], {\n      operation: 'get',\n      key: key\n    })\n\n    if response &amp;&amp; response[:found]\n      send_response(\n        found: true,\n        value: response[:value],\n        node: node_name\n      )\n    else\n      send_response(\n        found: false,\n        node: node_name\n      )\n    end\n  end\n\n  def set_in_cache(key, value, ttl = nil)\n    node_name = @ring.get_node(key)\n    node = @cache_nodes[node_name]\n\n    return send_error(\"No cache nodes available\", \"NO_CACHE_NODES\") unless node\n\n    response = send_request(node[:name], {\n      operation: 'set',\n      key: key,\n      value: value,\n      ttl: ttl\n    })\n\n    send_response(\n      stored: response &amp;&amp; response[:stored],\n      node: node_name\n    )\n  end\n\n  def delete_from_cache(key)\n    node_name = @ring.get_node(key)\n    node = @cache_nodes[node_name]\n\n    return send_error(\"No cache nodes available\", \"NO_CACHE_NODES\") unless node\n\n    response = send_request(node[:name], {\n      operation: 'delete',\n      key: key\n    })\n\n    send_response(\n      deleted: response &amp;&amp; response[:deleted],\n      node: node_name\n    )\n  end\n\n  def get_cache_stats\n    stats = {}\n\n    @cache_nodes.each do |node_name, node|\n      response = send_request(node[:name], { operation: 'stats' })\n      stats[node_name] = response if response\n    end\n\n    send_response(\n      node_stats: stats,\n      total_nodes: @cache_nodes.size\n    )\n  end\nend\n\n# Simple consistent hash ring implementation\nclass ConsistentHashRing\n  def initialize\n    @ring = {}\n    @sorted_keys = []\n  end\n\n  def add_node(node_name, virtual_nodes = 150)\n    virtual_nodes.times do |i|\n      key = Digest::SHA1.hexdigest(\"#{node_name}:#{i}\").to_i(16)\n      @ring[key] = node_name\n    end\n    @sorted_keys = @ring.keys.sort\n  end\n\n  def get_node(key)\n    return nil if @ring.empty?\n\n    hash = Digest::SHA1.hexdigest(key.to_s).to_i(16)\n\n    # Find first node &gt;= hash\n    idx = @sorted_keys.bsearch_index { |k| k &gt;= hash }\n    idx ||= 0  # Wrap around to first node\n\n    @ring[@sorted_keys[idx]]\n  end\nend\n</code></pre>"},{"location":"examples/advanced-examples/#cache-node","title":"Cache Node","text":"<pre><code>class CacheNodeAgent &lt; Agent99::Base\n  def initialize(node_id = nil)\n    super\n    @node_id = node_id || \"cache_#{SecureRandom.hex(4)}\"\n    @cache = {}\n    @stats = { gets: 0, sets: 0, deletes: 0, hits: 0, misses: 0 }\n    @mutex = Mutex.new\n\n    # Start TTL cleanup thread\n    start_ttl_cleanup\n  end\n\n  def info\n    {\n      name: \"#{self.class}_#{@node_id}\",\n      type: :server,\n      capabilities: ['cache_node', 'storage']\n    }\n  end\n\n  def process_request(payload)\n    operation = payload.dig(:operation)\n\n    case operation\n    when 'get'\n      get_value(payload[:key])\n    when 'set'\n      set_value(payload[:key], payload[:value], payload[:ttl])\n    when 'delete'\n      delete_value(payload[:key])\n    when 'stats'\n      get_stats\n    when 'clear'\n      clear_cache\n    else\n      send_error(\"Unknown operation: #{operation}\", \"INVALID_OPERATION\")\n    end\n  end\n\n  private\n\n  def get_value(key)\n    @mutex.synchronize do\n      @stats[:gets] += 1\n\n      entry = @cache[key]\n\n      if entry &amp;&amp; !expired?(entry)\n        @stats[:hits] += 1\n        send_response(\n          found: true,\n          value: entry[:value],\n          expires_at: entry[:expires_at]\n        )\n      else\n        @stats[:misses] += 1\n        @cache.delete(key) if entry # Clean up expired entry\n        send_response(found: false)\n      end\n    end\n  end\n\n  def set_value(key, value, ttl = nil)\n    @mutex.synchronize do\n      @stats[:sets] += 1\n\n      entry = {\n        value: value,\n        created_at: Time.now,\n        expires_at: ttl ? Time.now + ttl : nil\n      }\n\n      @cache[key] = entry\n\n      send_response(\n        stored: true,\n        expires_at: entry[:expires_at]\n      )\n    end\n  end\n\n  def delete_value(key)\n    @mutex.synchronize do\n      @stats[:deletes] += 1\n      deleted = @cache.delete(key)\n\n      send_response(deleted: !deleted.nil?)\n    end\n  end\n\n  def get_stats\n    @mutex.synchronize do\n      send_response(\n        node_id: @node_id,\n        stats: @stats.dup,\n        cache_size: @cache.size,\n        memory_usage: estimate_memory_usage\n      )\n    end\n  end\n\n  def clear_cache\n    @mutex.synchronize do\n      cleared_count = @cache.size\n      @cache.clear\n\n      send_response(\n        cleared: true,\n        entries_removed: cleared_count\n      )\n    end\n  end\n\n  def expired?(entry)\n    entry[:expires_at] &amp;&amp; entry[:expires_at] &lt; Time.now\n  end\n\n  def estimate_memory_usage\n    # Simple memory estimation\n    @cache.to_s.bytesize\n  end\n\n  def start_ttl_cleanup\n    Thread.new do\n      loop do\n        sleep(60) # Run every minute\n\n        @mutex.synchronize do\n          expired_keys = @cache.select { |k, v| expired?(v) }.keys\n          expired_keys.each { |key| @cache.delete(key) }\n\n          logger.debug \"Cleaned up #{expired_keys.size} expired cache entries\" if expired_keys.any?\n        end\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"examples/advanced-examples/#real-time-analytics-pipeline","title":"Real-time Analytics Pipeline","text":"<p>Building a real-time analytics system:</p>"},{"location":"examples/advanced-examples/#data-ingestion-agent","title":"Data Ingestion Agent","text":"<pre><code>class DataIngestionAgent &lt; Agent99::Base\n  def initialize\n    super\n    @buffer = []\n    @buffer_mutex = Mutex.new\n    @batch_size = 100\n    @flush_interval = 30 # seconds\n\n    start_batch_processor\n  end\n\n  def info\n    {\n      name: self.class.to_s,\n      type: :hybrid,\n      capabilities: ['data_ingestion', 'stream_processing']\n    }\n  end\n\n  def process_request(payload)\n    action = payload.dig(:action)\n\n    case action\n    when 'ingest'\n      ingest_data(payload[:data])\n    when 'flush'\n      flush_buffer\n    when 'stats'\n      get_ingestion_stats\n    else\n      send_error(\"Unknown action: #{action}\", \"INVALID_ACTION\")\n    end\n  end\n\n  private\n\n  def ingest_data(data)\n    enriched_data = {\n      id: SecureRandom.uuid,\n      raw_data: data,\n      ingested_at: Time.now.iso8601,\n      source_ip: header_value('source_ip'),\n      user_agent: header_value('user_agent')\n    }\n\n    @buffer_mutex.synchronize do\n      @buffer &lt;&lt; enriched_data\n\n      if @buffer.size &gt;= @batch_size\n        flush_buffer_unsafe\n      end\n    end\n\n    send_response(\n      ingested: true,\n      data_id: enriched_data[:id],\n      buffer_size: @buffer.size\n    )\n  end\n\n  def flush_buffer\n    @buffer_mutex.synchronize do\n      flush_buffer_unsafe\n    end\n  end\n\n  def flush_buffer_unsafe\n    return if @buffer.empty?\n\n    batch = @buffer.dup\n    @buffer.clear\n\n    # Send to analytics processor\n    analytics_agents = discover_agents(['analytics_processor'])\n\n    if analytics_agents.any?\n      analytics_agent = analytics_agents.first\n\n      Thread.new do\n        send_request(analytics_agent[:name], {\n          action: 'process_batch',\n          batch: batch,\n          batch_size: batch.size\n        })\n      end\n    else\n      logger.warn \"No analytics processors available, data lost\"\n    end\n\n    logger.info \"Flushed batch of #{batch.size} records\"\n  end\n\n  def start_batch_processor\n    Thread.new do\n      loop do\n        sleep(@flush_interval)\n        flush_buffer\n      end\n    end\n  end\n\n  def get_ingestion_stats\n    @buffer_mutex.synchronize do\n      send_response(\n        buffer_size: @buffer.size,\n        batch_size: @batch_size,\n        flush_interval: @flush_interval\n      )\n    end\n  end\nend\n</code></pre> <p>These advanced examples demonstrate:</p> <ul> <li>Complex microservices architectures with multiple interacting services</li> <li>Event-driven patterns with pub/sub messaging</li> <li>Distributed systems concepts like consistent hashing and caching</li> <li>Real-time data processing with buffering and batch processing</li> <li>Error handling and resilience patterns</li> <li>Performance optimization techniques</li> <li>Production-ready patterns with monitoring and stats</li> </ul> <p>Each example can be extended further with additional features like: - Persistence layers (databases, file systems) - Authentication and authorization - Rate limiting and throttling - Circuit breakers and retry logic - Distributed tracing and monitoring - Configuration management - Health checks and service discovery</p>"},{"location":"examples/advanced-examples/#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Agent Processing - Coordination patterns</li> <li>Performance Considerations - Optimization techniques</li> <li>Configuration - Production deployment settings</li> </ul>"},{"location":"examples/basic-examples/","title":"Basic Examples","text":"<p>This section contains basic examples to help you get started with Agent99.</p>"},{"location":"examples/basic-examples/#simple-greeter-agent","title":"Simple Greeter Agent","text":"<p>Here's a basic server agent that responds to greeting requests:</p> <pre><code>require 'agent99'\nrequire 'simple_json_schema_builder'\n\n# Define the request schema\nclass GreeterRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n    string :name, required: true, examples: [\"World\"]\n  end\nend\n\n# Create the agent\nclass GreeterAgent &lt; Agent99::Base\n  def info\n    {\n      name:             self.class.to_s,\n      type:             :server,\n      capabilities:     ['greeter', 'hello_world'],\n      request_schema:   GreeterRequest.schema\n    }\n  end\n\n  def process_request(payload)\n    name = payload.dig(:name) || \"World\"\n    response = { result: \"Hello, #{name}!\" }\n    send_response(response)\n  end\nend\n\n# Run the agent\nif __FILE__ == $0\n  agent = GreeterAgent.new\n  puts \"Starting Greeter Agent...\"\n  agent.run\nend\n</code></pre>"},{"location":"examples/basic-examples/#echo-agent","title":"Echo Agent","text":"<p>An agent that echoes back whatever message it receives:</p> <pre><code>require 'agent99'\n\nclass EchoAgent &lt; Agent99::Base\n  def info\n    {\n      name:           self.class.to_s,\n      type:           :server,\n      capabilities:   ['echo', 'mirror']\n    }\n  end\n\n  def process_request(payload)\n    logger.info \"Echo agent received: #{payload}\"\n    send_response(message: \"You said: #{payload}\")\n  end\nend\n\n# Run the agent\nif __FILE__ == $0\n  agent = EchoAgent.new\n  puts \"Starting Echo Agent...\"\n  agent.run\nend\n</code></pre>"},{"location":"examples/basic-examples/#calculator-agent","title":"Calculator Agent","text":"<p>A more complex agent that performs basic arithmetic operations:</p> <pre><code>require 'agent99'\nrequire 'simple_json_schema_builder'\n\nclass CalculatorRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n    string :operation, enum: %w[add subtract multiply divide], required: true\n    number :a, required: true\n    number :b, required: true\n  end\nend\n\nclass CalculatorAgent &lt; Agent99::Base\n  def info\n    {\n      name:             self.class.to_s,\n      type:             :server,\n      capabilities:     ['calculator', 'math', 'arithmetic'],\n      request_schema:   CalculatorRequest.schema\n    }\n  end\n\n  def process_request(payload)\n    operation = payload.dig(:operation)\n    a = payload.dig(:a).to_f\n    b = payload.dig(:b).to_f\n\n    result = case operation\n    when 'add'\n      a + b\n    when 'subtract'\n      a - b\n    when 'multiply'\n      a * b\n    when 'divide'\n      return send_error(\"Division by zero\") if b == 0\n      a / b\n    else\n      return send_error(\"Unknown operation: #{operation}\")\n    end\n\n    send_response(result: result, operation: operation, inputs: { a: a, b: b })\n  end\nend\n\n# Run the agent\nif __FILE__ == $0\n  agent = CalculatorAgent.new\n  puts \"Starting Calculator Agent...\"\n  agent.run\nend\n</code></pre>"},{"location":"examples/basic-examples/#client-agent-example","title":"Client Agent Example","text":"<p>An agent that makes requests to other agents:</p> <pre><code>require 'agent99'\n\nclass ClientAgent &lt; Agent99::Base\n  def info\n    {\n      name:           self.class.to_s,\n      type:           :client,\n      capabilities:   ['client', 'requester']\n    }\n  end\n\n  def start\n    # Find available agents\n    agents = discover_agents(['greeter'])\n\n    if agents.any?\n      greeter = agents.first\n      logger.info \"Found greeter agent: #{greeter[:name]}\"\n\n      # Send a request\n      request = {\n        name: \"Agent99 Client\"\n      }\n\n      response = send_request(greeter[:name], request)\n      logger.info \"Received response: #{response}\"\n    else\n      logger.warn \"No greeter agents found\"\n    end\n  end\nend\n\n# Run the client\nif __FILE__ == $0\n  client = ClientAgent.new\n  puts \"Starting Client Agent...\"\n\n  # Run once and exit\n  client.start\nend\n</code></pre>"},{"location":"examples/basic-examples/#hybrid-agent-example","title":"Hybrid Agent Example","text":"<p>An agent that can both serve requests and make requests to other agents:</p> <pre><code>require 'agent99'\n\nclass HybridAgent &lt; Agent99::Base\n  def info\n    {\n      name:           self.class.to_s,\n      type:           :hybrid,\n      capabilities:   ['proxy', 'forwarder']\n    }\n  end\n\n  def process_request(payload)\n    # This agent forwards requests to other agents\n    target_capability = payload.dig(:forward_to)\n    message = payload.dig(:message)\n\n    if target_capability &amp;&amp; message\n      # Find agents with the target capability\n      agents = discover_agents([target_capability])\n\n      if agents.any?\n        target_agent = agents.first\n\n        # Forward the message\n        response = send_request(target_agent[:name], { name: message })\n        send_response(forwarded_response: response, target_agent: target_agent[:name])\n      else\n        send_error(\"No agents found with capability: #{target_capability}\")\n      end\n    else\n      send_error(\"Missing 'forward_to' or 'message' in request\")\n    end\n  end\nend\n\n# Run the agent\nif __FILE__ == $0\n  agent = HybridAgent.new\n  puts \"Starting Hybrid Agent...\"\n  agent.run\nend\n</code></pre>"},{"location":"examples/basic-examples/#running-the-examples","title":"Running the Examples","text":"<ol> <li> <p>Start the Registry:     <pre><code>ruby examples/registry.rb\n</code></pre></p> </li> <li> <p>Start a Message Broker (NATS or RabbitMQ):    <pre><code>nats-server\n# OR\nrabbitmq-server\n</code></pre></p> </li> <li> <p>Run the Agents:    <pre><code># In separate terminals\nruby greeter_agent.rb\nruby calculator_agent.rb\nruby client_agent.rb\n</code></pre></p> </li> </ol>"},{"location":"examples/basic-examples/#testing-agent-communication","title":"Testing Agent Communication","text":"<p>You can test agent communication using the client example or by sending HTTP requests to the registry:</p> <pre><code># List all registered agents\ncurl http://localhost:4567/agents\n\n# Find agents by capability\ncurl http://localhost:4567/agents/discover/greeter\n</code></pre>"},{"location":"examples/basic-examples/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Examples - More complex agent patterns</li> <li>Schema Definition - Learn about request/response schemas</li> <li>Message Processing - Understand message handling</li> </ul>"},{"location":"framework-components/agent-discovery/","title":"Agent99 Framework","text":""},{"location":"framework-components/agent-discovery/#agent-discovery","title":"Agent Discovery","text":"<p>Agents within the Agent99 Framework can efficiently discover one another based on their declared capabilities. This feature fosters dynamic interactions that enhance the collaborative functionality of the agents.</p>"},{"location":"framework-components/agent-discovery/#overview","title":"Overview","text":"<p>The agent discovery process involves the following steps:</p> <ol> <li>Registration: Agents register their capabilities with a central registry upon startup.</li> <li>Discovery: When an agent needs to discover other agents, it queries the registry for agents with specific capabilities.</li> <li>Response: The registry responds with a list of available agents, allowing them to interact based on their capabilities.</li> </ol>"},{"location":"framework-components/agent-discovery/#declaring-capabilities-in-the-info-method","title":"Declaring Capabilities in the Info Method","text":"<p>Each agent must implement the <code>info</code> method to declare its capabilities as an array of strings:</p> <pre><code>def info\n  {\n    # ...\n    capabilities:  ['process_image', 'face_detection'],\n    # ...\n  }\nend\n</code></pre> <p>Note: The discovery mechanism is based on an exact match (case insensitive) between the requested capability and the entries in the agent's capabilities array in its information packet. For example, if an agent declares its capabilities as mentioned above, a discovery request for <code>'FACE_DETECTION'</code> will successfully match.</p>"},{"location":"framework-components/agent-discovery/#discovery-api","title":"Discovery API","text":"<p>To find other agents, use the <code>discover_agent</code> method. Here are some usage examples:</p> <pre><code># Find a single agent with a specific capability\nagent = discover_agent(capability: 'face_detection')\n\n# Find multiple agents \nagents = discover_agent(capability: 'process_image', how_many: 3)\n\n# Find all agents with a specific capability\nall_agents = discover_agent(capability: 'process_image', all: true)\n</code></pre>"},{"location":"framework-components/agent-discovery/#important-note-on-capabilities","title":"Important Note on Capabilities","text":"<ul> <li>Single Capability: A seeking agent can only request one kind of capability at a time.</li> <li>Semantics-Based Capabilities: The development roadmap includes enhancements towards semantic-based capabilities that could allow for more complex interactions between agents in the future.  This would be a change from the current Array of Strings to a single String that is a description of the services the agent provides.  This would be consistent with the way in which LLMs currently find Tools for augmented generation.</li> </ul>"},{"location":"framework-components/agent-discovery/#registry-configuration","title":"Registry Configuration","text":"<p>The registry client comes with default settings, which you can override as needed:</p> <ul> <li>URL: Default is <code>http://localhost:4567</code> (you can override this using the <code>REGISTRY_BASE_URL</code> environment variable).</li> <li>Interface: Supports a standard HTTP REST interface.</li> <li>Reconnection: Automatic reconnection handling is provided to ensure reliable communication.</li> </ul>"},{"location":"framework-components/agent-discovery/#best-practices","title":"Best Practices","text":"<ol> <li>Check Discovery Success: Always verify if agent discovery succeeded before attempting to establish communication with the discovered agent.</li> <li>Use Specific Capability Names: This ensures that the correct agents are matched during the discovery process, avoiding ambiguity.</li> <li>Implement Multiple Capabilities: Consider declaring multiple capabilities per agent to enhance its versatility and improve interaction possibilities.</li> </ol> <p>With these guidelines, you can effectively implement and utilize the agent discovery feature within the Agent99 Framework, ensuring robust and dynamic interactions among agents based on their declared capabilities.</p>"},{"location":"framework-components/agent-registry/","title":"Agent99 Framework","text":""},{"location":"framework-components/agent-registry/#agent-registry-processes","title":"Agent Registry Processes","text":"<p>In the Agent99 framework, an instance of the <code>Agent99::RegistryClient</code> class is responsible for registering agent capabilities with a centralized registry.  <code>examples/registry.rb</code> is a Sinatra web-app example of what a centralized regristry service should be. </p> <p>The registration process is transparent to a new instance of an <code>Agent99::Base</code> class.</p> <p>First thing: start the registry.rb Sinatra app and the peer-to-peer messaging network.  The default is the <code>AmqpMessageClient</code> class.</p> <p>If you do not have the RabbitMQ server installed on your Macthen then grab it using <code>brew install rabbitmq-server</code> and while you are installing software do <code>brew install boxes</code> as well since the <code>chief_agent.rb</code> example uses that little CLI tool to highlight some text in the terminal.</p> <pre><code>git clone ssh://git@github.com/MadBomber/agent99\nbrew install rabbitmq-server boxes\ngem install agent99\n\ncd agent99/examples\n./start_rabbitmq_and_registry.sh\n</code></pre> <p>Now go into <code>irb</code> in a different terminal window and try this code ...</p> <pre><code>require 'agent99'\n\n# Define the Schema for the Agent's request payload\n\nclass MyAgentRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n\n    string :greeting, required: false,  examples: [\"Hello\"]\n    string :name,     required: true,   examples: [\"World\"]\n  end\nend\n\n# Define the new Agent ....\n\nclass MyAgent &lt; Agent99::Base\n  def info\n    {\n      # ...\n      request_schema: MyAgentRequest.schema\n      capabilities:   %w[ greeter hello_world ],\n      # ...\n    }\n  end\nend\n\n# You may create multiple instances of the agent if needed\n\nmy_agent = MyAgent.new\n\nI, [2024-12-07T14:42:08.140286 #36471]  INFO -- : Registered Agent MyAgent with ID: 9e735449-582f-46e2-8f11-371e584d0f08\nI, [2024-12-07T14:42:08.141978 #36471]  INFO -- : Created queue for agent_id: 9e735449-582f-46e2-8f11-371e584d0f08\n  #=&gt;\n#&lt;MyAgent:0x000000011d4d2e48\n...\n\n# The agent as an ID and an address in the peer-to-peer network\n\nmy_agent.id\n  #=&gt; \"9e735449-582f-46e2-8f11-371e584d0f08\"\n</code></pre> <p>The image below shows how the <code>Agent99::Base</code> class uses dependency injection in its constructor method to bring in an instance of the <code>RegristryClient</code> class to provide an interface to the centralized regristery service.</p> <p></p> <p>The above image also show the other services provided via the RegistryClient class.</p> <p>The example centralized regristry service provides three processes:</p> <ol> <li>Registration Process:<ul> <li>MyAgent initializes the RegistryClient</li> <li>RegistryClient sends a POST request to the Central Registry</li> <li>Central Registry responds with a UUID</li> <li>RegistryClient returns the UUID to MyAgent</li> </ul> </li> <li>Discovery Process:<ul> <li>MyAgent requests discovery of agents with a specific capability</li> <li>RegistryClient sends a GET request to the Central Registry</li> <li>Central Registry responds with matching agents</li> <li>RegistryClient returns the matching agents to MyAgent</li> </ul> </li> <li>Withdrawal Process:<ul> <li>MyAgent requests withdrawal using its UUID</li> <li>RegistryClient sends a DELETE request to the Central Registry</li> <li>Central Registry responds with a 204 No Content</li> <li>RegistryClient confirms the withdrawal to MyAgent</li> </ul> </li> </ol> <p>Like the register process, the withdraw process is also transparent.  Its executed on any exit via the public method <code>fini</code> in the base class' <code>on_exit {...}</code> handler.  Calling <code>exit</code> for any reason within your agent class will withdraw it from the central registry and remove its message queue from peer-to-peer messaging network.</p> <p>The discover process is primary business logic for your agent class.  You must call the <code>@registry_client.discover(capability: \"whatever\")</code> method directly within the agents process.</p> <p>For example suppose your agent needs to work with other agents that provide the \"pne\", \"twp\" and \"three\" services.  That is 3 outside agents.  You can do this in the <code>init</code> method for you agent.</p> <pre><code>class MyAgent &lt; Agent99::Base\n  def init\n    @agnet_1 = discover_agent(capability: 'one')\n    @agnet_2 = discover_agent(capability: 'two')\n    @agnet_3 = discover_agent(capability: 'three')\n  end\nend\n</code></pre> <p><code>discover_agent</code> is the <code>Agent99::Base</code> method that links to the registry client's instance to do the discovery via the central registry.  Other parameters to <code>discover_agent</code> allow's you agent to specify <code>how_many</code> agents having the specify capability you want returned.  The default is 1.  If you want all the agents capable of providing the requested service use the <code>all: true</code> parameter with the <code>discover_agent</code> method.</p>"},{"location":"framework-components/message-processing/","title":"Agent99 Framework","text":""},{"location":"framework-components/message-processing/#message-processing","title":"Message Processing","text":"<p>The Agent99 framework implements a robust message processing system that handles three main types of messages: Request, Response, and Control messages. Each message type follows specific processing flows and validation rules.</p>"},{"location":"framework-components/message-processing/#message-types","title":"Message Types","text":"<ol> <li> <p>Request Messages</p> <ul> <li>Sent by clients to request services or actions</li> <li>Must include a valid schema definition</li> <li>Processed through the <code>receive_request</code> handler</li> <li>Automatically validated against REQUEST_SCHEMA</li> <li>Can trigger responses back to the sender</li> </ul> </li> <li> <p>Response Messages</p> <ul> <li>Sent in reply to requests</li> <li>Contain results or error information</li> <li>Processed through the <code>receive_response</code> handler</li> <li>Include original request reference</li> <li>May trigger additional processing flows</li> </ul> </li> <li> <p>Control Messages</p> <ul> <li>Manage agent lifecycle and behavior</li> <li>Include actions like shutdown, pause, resume</li> <li>Processed through dedicated control handlers</li> <li>Support configuration updates</li> <li>Enable status monitoring</li> </ul> </li> </ol>"},{"location":"framework-components/message-processing/#message-processing-flow","title":"Message Processing Flow","text":""},{"location":"framework-components/message-processing/#request-processing","title":"Request Processing","text":"<ol> <li>Message arrives and is validated against schema</li> <li>If validation passes:<ul> <li><code>receive_request</code> is called</li> <li>Custom processing occurs</li> <li>Optional response is sent</li> </ul> </li> <li>If validation fails:<ul> <li>Error response is automatically sent</li> <li>Error is logged</li> <li>Request is not processed further</li> </ul> </li> </ol>"},{"location":"framework-components/message-processing/#response-processing","title":"Response Processing","text":"<ol> <li>Response message is received</li> <li><code>receive_response</code> handler is called</li> <li>Response data is processed</li> <li>Any follow-up actions are triggered</li> </ol>"},{"location":"framework-components/message-processing/#control-processing","title":"Control Processing","text":"<ol> <li>Control message is received</li> <li>Action is identified</li> <li>Appropriate handler is called:<ul> <li><code>handle_shutdown</code></li> <li><code>handle_pause</code></li> <li><code>handle_resume</code></li> <li><code>handle_update_config</code></li> <li><code>handle_status_request</code></li> </ul> </li> <li>Control response is sent if needed</li> </ol>"},{"location":"framework-components/message-processing/#error-handling","title":"Error Handling","text":"<p>The framework provides comprehensive error handling:</p> <ol> <li> <p>Validation Errors</p> <ul> <li>Schema validation failures</li> <li>Missing required fields</li> <li>Invalid data types</li> </ul> </li> <li> <p>Processing Errors</p> <ul> <li>Handler exceptions</li> <li>Resource unavailability</li> <li>Timeout conditions</li> </ul> </li> <li> <p>System Errors</p> <ul> <li>Connection issues</li> <li>Resource constraints</li> <li>Framework-level problems</li> </ul> </li> </ol>"},{"location":"framework-components/message-processing/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Message Validation</p> <ul> <li>Always define REQUEST_SCHEMA for request-handling agents</li> <li>Include comprehensive examples in schema</li> <li>Validate message structure</li> </ul> </li> <li> <p>Error Handling</p> <ul> <li>Implement robust error handling in handlers</li> <li>Return meaningful error messages</li> <li>Log all significant events</li> </ul> </li> <li> <p>Response Management</p> <ul> <li>Send responses promptly</li> <li>Include relevant context</li> <li>Handle partial success cases</li> </ul> </li> <li> <p>Control Messages</p> <ul> <li>Respond to all control messages</li> <li>Implement graceful shutdown</li> <li>Maintain agent state properly</li> </ul> </li> </ol>"},{"location":"framework-components/message-processing/#implementation-example","title":"Implementation Example","text":"<pre><code>class MyAgent &lt; Agent99::Base\n  REQUEST_SCHEMA = {\n    type: \"object\",\n    properties: {\n      header: HEADER_SCHEMA,\n      data: {\n        type: \"object\",\n        required: [\"action\"],\n        properties: {\n          action: { type: \"string\" }\n        }\n      }\n    }\n  }\n\n  def receive_request\n    action = payload.dig(:data, :action)\n    result = process_action(action)\n    send_response(result)\n  rescue StandardError =&gt; e\n    send_response(error: e.message)\n  end\n\n  private\n\n  def process_action(action)\n    # Custom processing logic\n    { status: \"success\", result: action }\n  end\nend\n</code></pre>"},{"location":"framework-components/message-processing/#message-structure","title":"Message Structure","text":"<p>All messages must include a header with: * <code>type</code>: Message type (request/response/control) * <code>to_uuid</code>: Destination agent ID * <code>from_uuid</code>: Sender agent ID * <code>event_uuid</code>: Unique event identifier * <code>timestamp</code>: Message creation time</p> <p>Example message structure: <pre><code>{\n  header: {\n    type: \"request\",\n    to_uuid: \"agent_123\",\n    from_uuid: \"agent_456\",\n    event_uuid: \"evt_789\",\n    timestamp: 1638360000000000\n  },\n  data: {\n    # Message-specific payload\n  }\n}\n</code></pre></p>"},{"location":"framework-components/messaging-system/","title":"Agent99 Framework","text":""},{"location":"framework-components/messaging-system/#messaging-systems","title":"Messaging Systems","text":"<p>Agent99 supports both AMQP and NATS messaging systems, allowing you to choose the most appropriate messaging backend for your needs. The framework provides a consistent interface regardless of which messaging system you use.</p>"},{"location":"framework-components/messaging-system/#supported-message-brokers","title":"Supported Message Brokers","text":""},{"location":"framework-components/messaging-system/#amqp-rabbitmq","title":"AMQP (RabbitMQ)","text":"<p>The AMQP implementation uses RabbitMQ as the message broker and provides:</p> <ul> <li>Durability: Messages can persist across broker restarts</li> <li>Queue TTL: Queues automatically expire after 60 seconds of inactivity</li> <li>Automatic Reconnection: Handles connection drops gracefully</li> <li>Default Configuration:   <pre><code>{\n  host: \"127.0.0.1\",\n  port: 5672,\n  ssl: false,\n  vhost: \"/\",\n  user: \"guest\",\n  pass: \"guest\",\n  heartbeat: :server,\n  frame_max: 131072,\n  auth_mechanism: \"PLAIN\"\n}\n</code></pre></li> </ul>"},{"location":"framework-components/messaging-system/#nats","title":"NATS","text":"<p>The NATS implementation provides:</p> <ul> <li>Lightweight: Simple pub/sub with minimal overhead</li> <li>Auto-Pruning: Automatically cleans up unused subjects</li> <li>High Performance: Optimized for speed and throughput</li> <li>Default Configuration: Uses NATS default connection settings</li> </ul>"},{"location":"framework-components/messaging-system/#choosing-a-message-client","title":"Choosing a Message Client","text":"<p>You can select your messaging backend when initializing an agent:</p> <pre><code># For AMQP\nagent = MyAgent.new(message_client: Agent99::AmqpMessageClient.new)\n\n# For NATS\nagent = MyAgent.new(message_client: Agent99::NatsMessageClient.new)\n</code></pre> <p>Or configure it via environment variables:</p> <p>TODO: Need to add this to the configuration class which is still TBD</p> <pre><code># For AMQP\nexport MESSAGE_SYSTEM=amqp\nexport RABBITMQ_URL=amqp://guest:guest@localhost:5672\n\n# For NATS\nexport MESSAGE_SYSTEM=nats\nexport NATS_URL=nats://localhost:4222\n</code></pre>"},{"location":"framework-components/messaging-system/#message-handling","title":"Message Handling","text":"<p>Both implementations support these core operations:</p> <ol> <li> <p>Queue Setup:    <pre><code>queue = message_client.setup(agent_id: id, logger: logger)\n</code></pre></p> </li> <li> <p>Message Publishing:    <pre><code>message_client.publish({\n  header: {\n    type:        \"request\",\n    to_uuid:     recipient_id,\n    from_uuid:   sender_id,\n    event_uuid:  event_id,\n    timestamp:   Agent99::Timestamp.new.to_i\n  },\n  data: payload # or whatever for the agent.\n})\n</code></pre></p> </li> <li> <p>Message Subscription:    <pre><code>message_client.listen_for_messages(\n  queue,\n  request_handler:   -&gt;(msg) { handle_request(msg) },\n  response_handler:  -&gt;(msg) { handle_response(msg) },\n  control_handler:   -&gt;(msg) { handle_control(msg) }\n)\n</code></pre></p> </li> </ol>"},{"location":"framework-components/messaging-system/#key-differences","title":"Key Differences","text":"<ol> <li>Queue Management:</li> <li>AMQP: Explicit queue creation and deletion</li> <li> <p>NATS: Implicit subject-based routing</p> </li> <li> <p>Message Persistence:</p> </li> <li>AMQP: Supports persistent messages and queues</li> <li> <p>NATS: Ephemeral messaging by default</p> </li> <li> <p>Error Handling:</p> </li> <li>AMQP: Provides detailed connection and channel errors</li> <li>NATS: Simplified error handling with auto-reconnect</li> </ol>"},{"location":"framework-components/messaging-system/#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling: Always wrap message operations in begin/rescue blocks</li> <li>Logging: Use the provided logger for debugging and monitoring</li> <li>Configuration: Use environment variables for deployment flexibility</li> <li>Testing: Test your agents with both messaging systems to ensure compatibility</li> </ol>"},{"location":"framework-components/messaging-system/#monitoring","title":"Monitoring","text":"<p>Both implementations provide logging for: - Message publication success/failure - Queue creation and deletion - Connection status - Error conditions</p> <p>Use the logger to monitor your messaging system: <pre><code>message_client.logger.level = Logger::DEBUG  # For detailed logging\n</code></pre></p>"},{"location":"getting-started/basic-example/","title":"Basic Example: Building a Calculator Service","text":"<p>This detailed example walks you through creating a complete calculator service using Agent99, demonstrating key concepts like schema validation, error handling, and agent discovery.</p>"},{"location":"getting-started/basic-example/#what-well-build","title":"What We'll Build","text":"<p>A distributed calculator system with: - Calculator Agent: Performs arithmetic operations - Client Agent: Sends calculation requests - Request/Response Schemas: Validates input and output - Error Handling: Graceful error management</p>"},{"location":"getting-started/basic-example/#step-1-define-the-request-schema","title":"Step 1: Define the Request Schema","text":"<p>Create <code>calculator_schemas.rb</code>:</p> <pre><code>require 'simple_json_schema_builder'\n\n# Request schema for calculator operations\nclass CalculatorRequest &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n    string :operation, enum: %w[add subtract multiply divide], required: true,\n           description: \"The arithmetic operation to perform\"\n    number :a, required: true, description: \"First operand\"\n    number :b, required: true, description: \"Second operand\"\n  end\nend\n\n# Response schema for calculator results\nclass CalculatorResponse &lt; SimpleJsonSchemaBuilder::Base\n  object do\n    object :header, schema: Agent99::HeaderSchema\n    number :result, required: true, description: \"The calculation result\"\n    string :operation, required: true, description: \"The operation performed\"\n    object :operands do\n      number :a, required: true\n      number :b, required: true\n    end\n    string :timestamp, required: true, description: \"When the calculation was performed\"\n  end\nend\n</code></pre>"},{"location":"getting-started/basic-example/#step-2-create-the-calculator-agent","title":"Step 2: Create the Calculator Agent","text":"<p>Create <code>calculator_agent.rb</code>:</p> <pre><code>require 'agent99'\nrequire_relative 'calculator_schemas'\n\nclass CalculatorAgent &lt; Agent99::Base\n  def info\n    {\n      name:             self.class.to_s,\n      type:             :server,\n      capabilities:     ['calculator', 'math', 'arithmetic'],\n      description:      'Performs basic arithmetic operations',\n      request_schema:   CalculatorRequest.schema,\n      response_schema:  CalculatorResponse.schema\n    }\n  end\n\n  def process_request(payload)\n    logger.info \"Received calculation request: #{payload}\"\n\n    # Extract and validate inputs\n    operation = payload.dig(:operation)\n    a = payload.dig(:a).to_f\n    b = payload.dig(:b).to_f\n\n    # Perform calculation\n    result = perform_calculation(operation, a, b)\n\n    if result.is_a?(Hash) &amp;&amp; result[:error]\n      # Send error response\n      send_error(result[:error], result[:code] || 'CALCULATION_ERROR')\n    else\n      # Send successful response\n      response = {\n        result: result,\n        operation: operation,\n        operands: { a: a, b: b },\n        timestamp: Time.now.iso8601\n      }\n\n      send_response(response)\n    end\n  end\n\n  private\n\n  def perform_calculation(operation, a, b)\n    case operation\n    when 'add'\n      a + b\n    when 'subtract'\n      a - b\n    when 'multiply'\n      a * b\n    when 'divide'\n      return { error: \"Division by zero is not allowed\", code: 'DIVISION_BY_ZERO' } if b == 0\n      a / b\n    else\n      { error: \"Unknown operation: #{operation}\", code: 'INVALID_OPERATION' }\n    end\n  end\nend\n\n# Run the agent if this file is executed directly\nif __FILE__ == $0\n  puts \"\ud83e\uddee Starting Calculator Agent...\"\n  agent = CalculatorAgent.new\n\n  # Handle graceful shutdown\n  trap('INT') do\n    puts \"\\n\ud83d\udc4b Shutting down Calculator Agent...\"\n    agent.shutdown\n    exit\n  end\n\n  agent.run\nend\n</code></pre>"},{"location":"getting-started/basic-example/#step-3-create-a-client-agent","title":"Step 3: Create a Client Agent","text":"<p>Create <code>calculator_client.rb</code>:</p> <pre><code>require 'agent99'\n\nclass CalculatorClient &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :client,\n      capabilities: ['calculator_client', 'testing']\n    }\n  end\n\n  def perform_calculations\n    # Find calculator agents\n    calculators = discover_agents(['calculator'])\n\n    if calculators.empty?\n      puts \"\u274c No calculator agents found!\"\n      return\n    end\n\n    calculator = calculators.first\n    puts \"\ud83c\udfaf Found calculator: #{calculator[:name]}\"\n\n    # Test calculations\n    test_cases = [\n      { operation: 'add', a: 10, b: 5, expected: 15 },\n      { operation: 'subtract', a: 10, b: 3, expected: 7 },\n      { operation: 'multiply', a: 4, b: 7, expected: 28 },\n      { operation: 'divide', a: 20, b: 4, expected: 5 },\n      { operation: 'divide', a: 10, b: 0, expected: 'ERROR' }  # This should error\n    ]\n\n    test_cases.each_with_index do |test_case, index|\n      puts \"\\n\ud83d\udccb Test #{index + 1}: #{test_case[:a]} #{test_case[:operation]} #{test_case[:b]}\"\n\n      begin\n        response = send_request(calculator[:name], test_case.reject { |k, _| k == :expected })\n\n        if response[:error]\n          puts \"\u26a0\ufe0f  Error: #{response[:error]} (#{response[:code]})\"\n          puts \"\u2705 Expected error!\" if test_case[:expected] == 'ERROR'\n        else\n          result = response[:result]\n          puts \"\ud83d\udcca Result: #{result}\"\n\n          if test_case[:expected] != 'ERROR'\n            if (result - test_case[:expected]).abs &lt; 0.001  # Handle floating point comparison\n              puts \"\u2705 Test passed!\"\n            else\n              puts \"\u274c Test failed! Expected #{test_case[:expected]}, got #{result}\"\n            end\n          end\n        end\n      rescue =&gt; e\n        puts \"\ud83d\udca5 Request failed: #{e.message}\"\n      end\n    end\n  end\nend\n\n# Run the client if this file is executed directly\nif __FILE__ == $0\n  puts \"\ud83d\udcf1 Starting Calculator Client...\"\n  client = CalculatorClient.new\n  client.perform_calculations\nend\n</code></pre>"},{"location":"getting-started/basic-example/#step-4-run-the-complete-example","title":"Step 4: Run the Complete Example","text":""},{"location":"getting-started/basic-example/#terminal-1-start-the-registry","title":"Terminal 1: Start the Registry","text":"<pre><code># From the agent99 repository\nruby examples/registry.rb\n</code></pre>"},{"location":"getting-started/basic-example/#terminal-2-start-nats-or-rabbitmq","title":"Terminal 2: Start NATS (or RabbitMQ)","text":"<pre><code>nats-server\n</code></pre>"},{"location":"getting-started/basic-example/#terminal-3-start-the-calculator-agent","title":"Terminal 3: Start the Calculator Agent","text":"<pre><code>ruby calculator_agent.rb\n</code></pre> <p>Expected output: <pre><code>\ud83e\uddee Starting Calculator Agent...\nINFO -- Agent CalculatorAgent registered successfully\nINFO -- Agent listening for messages...\n</code></pre></p>"},{"location":"getting-started/basic-example/#terminal-4-run-the-client","title":"Terminal 4: Run the Client","text":"<pre><code>ruby calculator_client.rb\n</code></pre> <p>Expected output: <pre><code>\ud83d\udcf1 Starting Calculator Client...\n\ud83c\udfaf Found calculator: CalculatorAgent\n\n\ud83d\udccb Test 1: 10 add 5\n\ud83d\udcca Result: 15.0\n\u2705 Test passed!\n\n\ud83d\udccb Test 2: 10 subtract 3\n\ud83d\udcca Result: 7.0\n\u2705 Test passed!\n\n\ud83d\udccb Test 3: 4 multiply 7\n\ud83d\udcca Result: 28.0\n\u2705 Test passed!\n\n\ud83d\udccb Test 4: 20 divide 4\n\ud83d\udcca Result: 5.0\n\u2705 Test passed!\n\n\ud83d\udccb Test 5: 10 divide 0\n\u26a0\ufe0f  Error: Division by zero is not allowed (DIVISION_BY_ZERO)\n\u2705 Expected error!\n</code></pre></p>"},{"location":"getting-started/basic-example/#step-5-explore-the-registry","title":"Step 5: Explore the Registry","text":"<p>While everything is running, visit http://localhost:4567/agents in your browser to see registered agents, or use curl:</p> <pre><code># List all agents\ncurl http://localhost:4567/agents | jq\n\n# Find calculator agents\ncurl http://localhost:4567/agents/discover/calculator | jq\n</code></pre>"},{"location":"getting-started/basic-example/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":""},{"location":"getting-started/basic-example/#agent-architecture","title":"\ud83c\udfd7\ufe0f Agent Architecture","text":"<ul> <li>Server Agent: Waits for and processes requests</li> <li>Client Agent: Discovers and communicates with other agents</li> <li>Registry: Central discovery service</li> </ul>"},{"location":"getting-started/basic-example/#schema-validation","title":"\ud83d\udcdd Schema Validation","text":"<ul> <li>Request Schema: Validates incoming requests</li> <li>Response Schema: Defines response structure</li> <li>Type Safety: Ensures data integrity</li> </ul>"},{"location":"getting-started/basic-example/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":"<ul> <li>Validation Errors: Invalid input handling</li> <li>Business Logic Errors: Division by zero, invalid operations</li> <li>Network Errors: Communication failures</li> </ul>"},{"location":"getting-started/basic-example/#agent-discovery","title":"\ud83d\udd0d Agent Discovery","text":"<ul> <li>Capability-based: Find agents by what they can do</li> <li>Dynamic: Agents can join and leave at runtime</li> <li>Fault-tolerant: Graceful handling of missing agents</li> </ul>"},{"location":"getting-started/basic-example/#whats-next","title":"What's Next?","text":"<ul> <li>Core Concepts - Deep dive into agent theory</li> <li>Schema Definition - Advanced schema patterns</li> <li>Advanced Examples - Complex multi-agent scenarios</li> <li>Error Handling - Comprehensive error strategies</li> </ul>"},{"location":"getting-started/basic-example/#exercises","title":"Exercises","text":"<p>Try extending this example:</p> <ol> <li>Add more operations: power, square root, factorial</li> <li>Add validation: check for reasonable input ranges</li> <li>Add persistence: log all calculations to a file</li> <li>Add monitoring: track success/failure rates</li> <li>Add authentication: require API keys for requests</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install Agent99 and set up your development environment.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Agent99 requires Ruby 3.3.0 or higher.</p> <p>Check your Ruby version:</p> <pre><code>ruby --version\n</code></pre> <p>If you need to install or upgrade Ruby, we recommend using rbenv or RVM.</p>"},{"location":"getting-started/installation/#install-the-gem","title":"Install the Gem","text":""},{"location":"getting-started/installation/#from-rubygems","title":"From RubyGems","text":"<pre><code>gem install agent99\n</code></pre>"},{"location":"getting-started/installation/#from-bundler","title":"From Bundler","text":"<p>Add this line to your application's Gemfile:</p> <pre><code>gem 'agent99'\n</code></pre> <p>And then execute:</p> <pre><code>bundle install\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>Clone the repository and install:</p> <pre><code>git clone https://github.com/MadBomber/agent99.git\ncd agent99\nbundle install\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>Agent99 automatically installs the following dependencies:</p> <ul> <li>bunny - AMQP messaging client</li> <li>nats-pure - NATS messaging client  </li> <li>simple_json_schema_builder - JSON schema validation</li> <li>sinatra - For the registry service</li> </ul>"},{"location":"getting-started/installation/#message-broker-setup","title":"Message Broker Setup","text":"<p>Agent99 supports multiple messaging backends. Choose one:</p>"},{"location":"getting-started/installation/#option-1-nats-recommended-for-development","title":"Option 1: NATS (Recommended for Development)","text":"<p>Install NATS server:</p> <pre><code># macOS\nbrew install nats-server\n\n# Ubuntu/Debian\napt-get install nats-server\n\n# Or download from https://nats.io/download/\n</code></pre> <p>Start NATS server:</p> <pre><code>nats-server\n</code></pre>"},{"location":"getting-started/installation/#option-2-rabbitmq-amqp","title":"Option 2: RabbitMQ (AMQP)","text":"<p>Install RabbitMQ:</p> <pre><code># macOS\nbrew install rabbitmq\n\n# Ubuntu/Debian  \napt-get install rabbitmq-server\n\n# Or download from https://www.rabbitmq.com/download.html\n</code></pre> <p>Start RabbitMQ:</p> <pre><code># macOS\nbrew services start rabbitmq\n\n# Ubuntu/Debian\nsystemctl start rabbitmq-server\n</code></pre>"},{"location":"getting-started/installation/#registry-service","title":"Registry Service","text":"<p>Agent99 uses a central registry for agent discovery. You can use the example registry or create your own.</p> <p>Start the example registry:</p> <pre><code># From the agent99 source directory\nruby examples/registry.rb\n</code></pre> <p>The registry will start on http://localhost:4567 by default.</p>"},{"location":"getting-started/installation/#environment-variables","title":"Environment Variables","text":"<p>Configure Agent99 using environment variables:</p> <pre><code># Registry URL (default: http://localhost:4567)\nexport AGENT99_REGISTRY_URL=http://localhost:4567\n\n# Message broker settings (see messaging documentation)\nexport RABBITMQ_URL=amqp://localhost\nexport NATS_URL=nats://localhost:4222\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>Verify your installation by running a simple test:</p> <pre><code>require 'agent99'\nputs \"Agent99 version: #{Agent99.version}\"\n</code></pre>"},{"location":"getting-started/installation/#development-dependencies","title":"Development Dependencies","text":"<p>If you're contributing to Agent99, install development dependencies:</p> <pre><code>bundle install --with development\n</code></pre> <p>This includes: - amazing_print - Pretty printing - debug_me - Debugging utilities - hashdiff - Hash comparison - mocha - Testing framework - tocer - Documentation generation</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Build your first agent</li> <li>Basic Example - Detailed walkthrough</li> <li>Configuration - Advanced setup options</li> </ul>"},{"location":"getting-started/overview/","title":"Agent99 Framework Overview","text":"<p>Agent99 is a Ruby framework for building distributed AI agents with peer-to-peer messaging capabilities. It provides a robust foundation for creating intelligent agents that can communicate, discover each other, and perform various tasks in a microservices architecture.</p>"},{"location":"getting-started/overview/#current-status","title":"Current Status","text":"<p>Version: 0.0.4 (Under Development)</p> <p>Development Status</p> <p>Agent99 is currently under active development. The initial release has no AI components - it's a generic client-server / request-response microservices system using peer-to-peer messaging brokers and a centralized agent registry.</p>"},{"location":"getting-started/overview/#key-features","title":"Key Features","text":"<ul> <li>Agent Types: Support for Server (responds to requests), Client (makes requests), and Hybrid (both) agents</li> <li>Messaging: Multiple messaging backends including AMQP (via Bunny) and NATS</li> <li>Agent Discovery: Central registry for finding agents by capabilities</li> <li>Lifecycle Management: Complete agent registration, message processing, and control actions</li> <li>Dynamic Loading: Runtime agent deployment via AgentWatcher</li> <li>Multi-threading: Run multiple agents in the same process with thread isolation</li> </ul>"},{"location":"getting-started/overview/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>Modular Design: Built with mixins for HeaderManagement, AgentDiscovery, ControlActions, AgentLifecycle, and MessageProcessing</li> <li>Multiple Message Clients: AMQP, NATS, and TCP implementations</li> <li>HTTP Registry: Simple HTTP-based service for agent discovery (default: localhost:4567)</li> <li>Schema Validation: JSON schema validation for requests and responses</li> </ul>"},{"location":"getting-started/overview/#future-vision","title":"Future Vision","text":"<p>The framework is designed with AI integration in mind, referencing protocols like: - Agent2Agent (A2A): Now under the Linux Foundation - Model Context Protocol: For AI model integration</p>"},{"location":"getting-started/overview/#quick-example","title":"Quick Example","text":"<pre><code>require 'agent99'\n\nclass GreeterAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['greeter', 'hello_world']\n    }\n  end\n\n  def process_request(payload)\n    name = payload.dig(:name)\n    response = { result: \"Hello, #{name}!\" }\n    send_response(response)\n  end\nend\n\n# Create and run the agent\nagent = GreeterAgent.new\nagent.run\n</code></pre>"},{"location":"getting-started/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Get Agent99 installed</li> <li>Quick Start - Build your first agent</li> <li>Basic Example - Detailed walkthrough</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with Agent99 in just a few minutes! This guide assumes you have Ruby 3.3.0+ installed.</p>"},{"location":"getting-started/quick-start/#step-1-install-agent99","title":"Step 1: Install Agent99","text":"<pre><code>gem install agent99\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-start-a-message-broker","title":"Step 2: Start a Message Broker","text":"<p>Agent99 needs a message broker for agent communication. Choose one:</p> NATS (Recommended)RabbitMQ <pre><code># Install NATS server\nbrew install nats-server  # macOS\n# OR download from https://nats.io/download/\n\n# Start NATS\nnats-server\n</code></pre> <pre><code># Install RabbitMQ\nbrew install rabbitmq  # macOS\n\n# Start RabbitMQ\nbrew services start rabbitmq\n</code></pre>"},{"location":"getting-started/quick-start/#step-3-start-the-registry","title":"Step 3: Start the Registry","text":"<p>The registry helps agents discover each other:</p> <pre><code># Clone the repository for examples\ngit clone https://github.com/MadBomber/agent99.git\ncd agent99\n\n# Start the registry\nruby examples/registry.rb\n</code></pre>"},{"location":"getting-started/quick-start/#step-4-create-your-first-agent","title":"Step 4: Create Your First Agent","text":"<p>Create a file called <code>my_first_agent.rb</code>:</p> <pre><code>require 'agent99'\n\nclass MyFirstAgent &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :server,\n      capabilities: ['greeting', 'hello']\n    }\n  end\n\n  def process_request(payload)\n    name = payload.dig(:name) || \"World\"\n    logger.info \"Processing greeting request for: #{name}\"\n\n    response = {\n      message: \"Hello, #{name}! Welcome to Agent99!\",\n      timestamp: Time.now.iso8601\n    }\n\n    send_response(response)\n  end\nend\n\n# Run the agent\nif __FILE__ == $0\n  puts \"\ud83e\udd16 Starting My First Agent...\"\n  agent = MyFirstAgent.new\n  agent.run\nend\n</code></pre>"},{"location":"getting-started/quick-start/#step-5-run-your-agent","title":"Step 5: Run Your Agent","text":"<pre><code>ruby my_first_agent.rb\n</code></pre> <p>You should see output like: <pre><code>\ud83e\udd16 Starting My First Agent...\nINFO -- Agent MyFirstAgent registered successfully\nINFO -- Agent listening for messages...\n</code></pre></p>"},{"location":"getting-started/quick-start/#step-6-test-your-agent","title":"Step 6: Test Your Agent","text":"<p>Create a simple client to test your agent (<code>test_client.rb</code>):</p> <pre><code>require 'agent99'\n\nclass TestClient &lt; Agent99::Base\n  def info\n    {\n      name: self.class.to_s,\n      type: :client,\n      capabilities: ['testing']\n    }\n  end\n\n  def test_greeting\n    # Discover greeting agents\n    agents = discover_agents(['greeting'])\n\n    if agents.any?\n      target_agent = agents.first\n      puts \"\ud83d\udce1 Found agent: #{target_agent[:name]}\"\n\n      # Send a request\n      request = { name: \"Agent99 User\" }\n      response = send_request(target_agent[:name], request)\n\n      puts \"\u2705 Response: #{response[:message]}\"\n    else\n      puts \"\u274c No greeting agents found\"\n    end\n  end\nend\n\n# Run the test\nif __FILE__ == $0\n  client = TestClient.new\n  client.test_greeting\nend\n</code></pre> <p>Run the test client: <pre><code>ruby test_client.rb\n</code></pre></p> <p>Expected output: <pre><code>\ud83d\udce1 Found agent: MyFirstAgent\n\u2705 Response: Hello, Agent99 User! Welcome to Agent99!\n</code></pre></p>"},{"location":"getting-started/quick-start/#success","title":"\ud83c\udf89 Success!","text":"<p>You've successfully:</p> <ul> <li>\u2705 Installed Agent99</li> <li>\u2705 Started a message broker and registry</li> <li>\u2705 Created and ran your first agent</li> <li>\u2705 Tested agent communication</li> </ul>"},{"location":"getting-started/quick-start/#whats-next","title":"What's Next?","text":"<ul> <li>Basic Example - More detailed walkthrough</li> <li>Core Concepts - Understand how agents work</li> <li>Examples - More agent patterns</li> <li>Agent Development - Build complex agents</li> </ul>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":"<p>Agent not starting? - Make sure NATS or RabbitMQ is running - Check that Ruby 3.3.0+ is installed: <code>ruby --version</code> - Verify the registry is running on port 4567</p> <p>Can't find agents? - Ensure all components (registry, broker, agents) are running - Check that agents are registering: visit http://localhost:4567/agents</p> <p>Need help? - Check the Troubleshooting Guide - Visit the GitHub repository for issues and discussions</p>"},{"location":"operations/breaking-changes/","title":"v0.0.4 is a Breaking Change","text":""},{"location":"operations/breaking-changes/#before","title":"Before","text":"<p>Each agent was required to implement a <code>capabilities</code> method that returned an Array of Strings in which the elements of the array were essentially synonyms describing the thing that the agent does.  The roadmap calls for this capabilities structure to become an unstructured String in which semmantic search will be used for discovery rather than exact matches.</p>"},{"location":"operations/breaking-changes/#after","title":"After","text":"<p>The capabilities is now just one of several within a Hash collection returned by a new method named <code>info</code> representing the agent's information packet.  The entire packet will be returned by the central regristry when the agent is discovered.</p> <p>The capabilities element of this new <code>info</code> hash still has the same requirement of being an Array of Strings with a promiss of becoming more later as the system becomes more sophisticated.</p> <p>The required elements of the <code>info</code> Hash are:</p> <ul> <li>name -- automaticall derived from the class name of the agent.</li> <li>type -- one of server, client or hybrid.</li> <li>capabilities -- An Array of Strings</li> <li>request_schema -- is required when the type is server</li> </ul> <p>The keys to the <code>info</code> Hash are Symbols.</p>"},{"location":"operations/breaking-changes/#modivation","title":"Modivation","text":"<p>The goal is to be able to mix and match multiple agents created by different developers in different languages within the context of the protocols and APIs of the Agent99 Framework.  To that end it seems reasonable that agents would have a need to share more than just their capabilitieis.  For example, their JSON schema for their request, response and control messages might also be something worth sharing.</p>"},{"location":"operations/configuration/","title":"Agent99 Framework","text":""},{"location":"operations/configuration/#configuration","title":"Configuration","text":"<p>Agents can be configured using environment variables. Key configuration options include:</p> <ul> <li><code>REGISTRY_BASE_URL</code>: Specifies the URL of the agent registry service (default: 'http://localhost:4567').</li> </ul>"},{"location":"operations/configuration/#environment-variables","title":"Environment Variables","text":"<p>To set an environment variable, use the following command in your terminal before running your application:</p> <pre><code>export REGISTRY_BASE_URL=http://my-registry-url\n</code></pre>"},{"location":"operations/performance-considerations/","title":"Agent99 Framework","text":""},{"location":"operations/performance-considerations/#performance-considerations","title":"Performance Considerations","text":"<p>To ensure optimal performance:</p> <ul> <li>Optimize message processing by minimizing complex logic in request handlers.</li> <li>Use asynchronous processing wherever possible to prevent blocking operations.</li> <li>Profile agent performance during development to identify bottlenecks.</li> </ul>"},{"location":"operations/security/","title":"Agent99 Framework","text":""},{"location":"operations/security/#security","title":"Security","text":"<p>While Agent99 focuses on communication efficiency, it is recommended to implement security measures like:</p> <ul> <li>Encrypting messages in transit.</li> <li>Using secure protocols for messaging (e.g., AMQPS or NATS with TLS).</li> <li>Implementing access control mechanisms for sensitive operations.</li> </ul>"},{"location":"operations/troubleshooting/","title":"Agent99 Framework","text":""},{"location":"operations/troubleshooting/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues may include:</p> <ul> <li>Failed registrations: Ensure that your registry URL is correctly configured.</li> <li>Message routing issues: Verify routing keys and message schemata.</li> <li>Unhandled exceptions: Check logs for details.</li> </ul> <p>For effective debugging, use the logging facilities provided and monitor agent activities.</p>"}]}